<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - Grass Controls</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #fps-display {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.5); color: #00ff00; 
            padding: 5px 10px; border-radius: 4px;
            font-family: monospace; font-weight: bold; font-size: 14px;
            pointer-events: none; z-index: 200;
        }

        #debug-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7); color: white;
            padding: 15px; border-radius: 8px;
            z-index: 200; width: 240px;
            max-height: 90vh; overflow-y: auto; 
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .panel-section { margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .section-title { font-size: 11px; text-transform: uppercase; color: #ffeb3b; margin-bottom: 8px; letter-spacing: 1px; font-weight: bold;}
        
        .control-group { margin-bottom: 8px; }
        .control-group label { display: block; font-size: 12px; margin-bottom: 2px; color: #ccc; }
        .control-group input[type=range] { width: 100%; cursor: pointer; accent-color: #ffeb3b; display: block; }
        .value-display { float: right; color: #ffeb3b; font-weight: bold; font-size: 12px; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
        
        #error-log {
            position: absolute; top: 0; left: 0; background: red; color: white; padding: 5px; font-size: 10px; display: none; z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="fps-display">FPS: 0</div>
    <div id="error-log"></div>
    
    <div id="debug-panel">
        <div class="panel-section">
            <div class="section-title">Generador de Hierba</div>
            
            <div class="control-group">
                <label>Densidad (Cantidad) <span id="val-grass-count" class="value-display">3000</span></label>
                <input type="range" id="input-grass-count" min="1000" max="20000" step="500" value="3000">
            </div>

            <div class="control-group">
                <label>Anchura Brizna <span id="val-grass-width" class="value-display">0.12</span></label>
                <input type="range" id="input-grass-width" min="0.05" max="0.3" step="0.01" value="0.12">
            </div>

            <div class="control-group">
                <label>Escala Ruido (Parches) <span id="val-grass-noise" class="value-display">0.1</span></label>
                <input type="range" id="input-grass-noise" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>
        </div>
    </div>

    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.168.0",
                "three/addons/": "https://esm.sh/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        window.addEventListener('error', function(e) {
            const el = document.getElementById('error-log');
            el.style.display = 'block';
            el.innerHTML += "Error: " + e.message + "<br>";
        });

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        let blobShadow;
        const clock = new THREE.Clock();
        
        let lastTime = performance.now();
        let frames = 0;
        const fpsDisplay = document.getElementById('fps-display');

        const collisionMeshes = [];
        let grassMeshes = []; // Array dinámico
        let parametricMesh = null; // Referencia a la malla generada
        
        const tempQuat = new THREE.Quaternion(); 
        const tempWindDir = new THREE.Vector3(); 
        
        // --- PARÁMETROS GLOBALES HIERBA ---
        const grassParams = {
            count: 3000,
            width: 0.12,
            noiseScale: 0.1,
            areaSize: 25
        };

        const windParams = { strength: 1.1, speed: 3.0 };

        // --- FÍSICAS ---
        const maxMoveSpeed = 11.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;
        let velocityY = 0;
        const gravity = -50.0; 
        const jumpStrength = 18.0; 
        let isGrounded = false;
        let landingCooldown = 0.0; 
        const LANDING_PAUSE_DURATION = 0.2; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const projectiles = [];
        const projectileSpeed = 20.0;
        
        // --- PARÁMETROS SOL FIJOS ---
        const sunDistance = 50; 
        let sunOffset = new THREE.Vector3(); 
        let sunElevation = 13; 
        let sunRotation = 270; 

        const LIGHT_SETTINGS = { sunInt: 6.0, ambInt: 0.0, color: 0xffeeb1 };

        const keyStates = { w: false, a: false, s: false, d: false };
        const camSettings = { radius: 4.5, minRadius: 1.5, currentRadius: 4.5, theta: Math.PI, phi: 0.45 };
        const cameraRaycaster = new THREE.Raycaster();
        
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) { x = (x / distance) * maxRadius; y = (y / distance) * maxRadius; }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius; joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => { isDraggingJoystick = false; joystickVector = { x: 0, y: 0 }; joystickThumb.style.transform = `translate(0px, 0px)`; };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        document.addEventListener('pointerdown', (e) => { if (e.target.closest('.ui-element') || e.target.closest('#debug-panel')) return; isDraggingCamera = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointermove', (e) => { if (!isDraggingCamera) return; const deltaX = e.clientX - previousMousePosition.x; const deltaY = e.clientY - previousMousePosition.y; camSettings.theta -= deltaX * 0.008; camSettings.phi -= deltaY * 0.008; camSettings.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camSettings.phi)); previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);
        document.addEventListener('keydown', (e) => { if(e.code==='KeyW') keyStates.w = true; if(e.code==='KeyS') keyStates.s = true; if(e.code==='KeyA') keyStates.a = true; if(e.code==='KeyD') keyStates.d = true; if(e.code==='Space') jump(); if(e.code==='KeyP') shoot(); });
        document.addEventListener('keyup', (e) => { if(e.code==='KeyW') keyStates.w = false; if(e.code==='KeyS') keyStates.s = false; if(e.code==='KeyA') keyStates.a = false; if(e.code==='KeyD') keyStates.d = false; });
        const jumpBtn = document.getElementById('btn-jump'); const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump)); jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot)); shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- INIT THREE ---
        const scene = new THREE.Scene();
        
        // Niebla (Atardecer)
        const fogColor = 0xeecfa1; 
        const fogDensity = 0.022;
        scene.fog = new THREE.FogExp2(fogColor, fogDensity);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 0.5; 
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        const bgTexture = textureLoader.load('./bg.webp', (texture) => { texture.colorSpace = THREE.SRGBColorSpace; });
        const iblTexture = textureLoader.load('./bg_reflejosIBL.webp', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.environment = texture; 
            scene.environmentIntensity = 2.0; 
            if(scene.environmentRotation) scene.environmentRotation.y = THREE.MathUtils.degToRad(334);
        });

        const shadowMat = new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1 });
        blobShadow = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), shadowMat);
        blobShadow.rotation.x = -Math.PI / 2; blobShadow.visible = false;
        scene.add(blobShadow);
        function createShadowTexture() { const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const ctx = canvas.getContext('2d'); const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(0,0,0,0.6)'); gradient.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64); return new THREE.CanvasTexture(canvas); }

        const sunLight = new THREE.DirectionalLight(LIGHT_SETTINGS.color, LIGHT_SETTINGS.sunInt);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048); 
        sunLight.shadow.radius = 2; 
        sunLight.shadow.bias = -0.001; 
        sunLight.shadow.normalBias = 0.08; 
        const d = 20; sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        scene.add(sunLight); scene.add(sunLight.target); 
        const hemiLight = new THREE.HemisphereLight(0xffd580, 0x222233, LIGHT_SETTINGS.ambInt);
        scene.add(hemiLight);

        function updateSun() {
            const phi = THREE.MathUtils.degToRad(90 - sunElevation); 
            const theta = THREE.MathUtils.degToRad(sunRotation);
            sunOffset.set(
                sunDistance * Math.sin(phi) * Math.sin(theta), 
                sunDistance * Math.cos(phi), 
                sunDistance * Math.sin(phi) * Math.cos(theta)
            );
        }
        updateSun(); 

        // --- CONTROLES UI HIERBA ---
        const uiCount = document.getElementById('input-grass-count');
        const valCount = document.getElementById('val-grass-count');
        uiCount.addEventListener('input', (e) => {
            grassParams.count = parseInt(e.target.value);
            valCount.innerText = grassParams.count;
            // Debounce simple o regenerar directo
            generateParametricGrass();
        });

        const uiWidth = document.getElementById('input-grass-width');
        const valWidth = document.getElementById('val-grass-width');
        uiWidth.addEventListener('input', (e) => {
            grassParams.width = parseFloat(e.target.value);
            valWidth.innerText = grassParams.width;
            generateParametricGrass();
        });

        const uiNoise = document.getElementById('input-grass-noise');
        const valNoise = document.getElementById('val-grass-noise');
        uiNoise.addEventListener('input', (e) => {
            grassParams.noiseScale = parseFloat(e.target.value);
            valNoise.innerText = grassParams.noiseScale;
            generateParametricGrass();
        });

        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false });
        sphereMat.color.setScalar(1.0);
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(123);
        scene.add(bgMesh);
        textureLoader.load('./Lightmap_Bake.webp', (t) => { t.flipY = false; t.channel = 1; }); 

        // --- GENERADOR DE HIERBA PARAMÉTRICA ---
        function generateParametricGrass() {
            // 1. Limpiar hierba paramétrica anterior
            if (parametricMesh) {
                scene.remove(parametricMesh);
                // Eliminar de la lista de animación
                const idx = grassMeshes.indexOf(parametricMesh);
                if (idx > -1) grassMeshes.splice(idx, 1);
                
                parametricMesh.geometry.dispose();
                parametricMesh.material.dispose();
                parametricMesh = null;
            }

            const count = grassParams.count;
            const areaSize = grassParams.areaSize;
            const w = grassParams.width;
            const h = 0.8;
            const nScale = grassParams.noiseScale;

            const positions = []; const colors = []; const indices = [];
            const color1 = new THREE.Color(0x3a5f0b); const color2 = new THREE.Color(0x7a9f2b); const tempColor = new THREE.Color();

            for (let i = 0; i < count; i++) {
                let x = (Math.random() - 0.5) * areaSize * 2; 
                let z = (Math.random() - 0.5) * areaSize * 2;
                
                // Ruido ajustado con slider
                const noise = Math.sin(x * nScale) * Math.sin(z * nScale) + Math.sin(x * (nScale * 3) + z * (nScale * 2)) * 0.5;
                if (noise < -0.2) continue; 
                
                const y = getEnvironmentHeight(new THREE.Vector3(x, 5, z));
                if (y < -100) continue; 

                const scaleY = 0.6 + Math.random() * 0.8; 
                const rotation = Math.random() * Math.PI * 2; 
                const finalH = h * scaleY;
                
                tempColor.lerpColors(color1, color2, Math.random());
                const cosR = Math.cos(rotation); const sinR = Math.sin(rotation);
                const transform = (lx, ly) => { return [x + lx * cosR, y + ly, z + lx * sinR]; };
                const vOffset = positions.length / 3;

                positions.push(...transform(-w/2, 0)); positions.push(...transform(w/2, 0));
                positions.push(...transform(-w/2 * 0.8, finalH * 0.33)); positions.push(...transform(w/2 * 0.8, finalH * 0.33));
                positions.push(...transform(-w/2 * 0.5, finalH * 0.66)); positions.push(...transform(w/2 * 0.5, finalH * 0.66));
                positions.push(...transform(0, finalH));

                const baseC = tempColor.clone().multiplyScalar(0.7); 
                colors.push(baseC.r, baseC.g, baseC.b); colors.push(baseC.r, baseC.g, baseC.b);
                colors.push(tempColor.r, tempColor.g, tempColor.b); colors.push(tempColor.r, tempColor.g, tempColor.b);
                colors.push(tempColor.r, tempColor.g, tempColor.b); colors.push(tempColor.r, tempColor.g, tempColor.b);
                const tipC = tempColor.clone().multiplyScalar(1.2); 
                colors.push(tipC.r, tipC.g, tipC.b);

                indices.push(vOffset, vOffset+1, vOffset+2); indices.push(vOffset+1, vOffset+3, vOffset+2);
                indices.push(vOffset+2, vOffset+3, vOffset+4); indices.push(vOffset+3, vOffset+5, vOffset+4);
                indices.push(vOffset+4, vOffset+5, vOffset+6);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            // IMPORTANTE: Guardar posiciones originales para el viento
            geometry.userData.originalPositions = geometry.attributes.position.array.slice();
            
            const material = new THREE.MeshStandardMaterial({ vertexColors: true, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1 });
            parametricMesh = new THREE.Mesh(geometry, material);
            parametricMesh.castShadow = true; 
            parametricMesh.receiveShadow = true;
            
            // Añadir al sistema
            scene.add(parametricMesh);
            grassMeshes.push(parametricMesh);
        }

        // --- ASSETS ---
        const gltfLoader = new GLTFLoader();

        gltfLoader.load('./MN_SCENE_01.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const bbox = new THREE.Box3().setFromObject(masterModule); const size = new THREE.Vector3(); bbox.getSize(size);
            
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    let moduleInstance = masterModule.clone(); moduleInstance.position.set(x * size.x, 0, z * size.z); scene.add(moduleInstance); 
                    moduleInstance.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true; child.receiveShadow = true; if (child.material) child.material.side = THREE.DoubleSide;
                            const name = child.name.toLowerCase();
                            // HIERBA DEL GLTF (ESTÁTICA, SE AÑADE UNA VEZ)
                            if ((name.includes("hierba") || (child.parent && child.parent.name.toLowerCase().includes("hierba"))) && !name.includes("montes")) {
                                child.geometry = child.geometry.clone();
                                const posAttribute = child.geometry.attributes.position;
                                // Guardamos posiciones en USERDATA del MESH (estandarizado)
                                child.userData.originalPositions = posAttribute.array.slice(); 
                                child.userData.worldOffset = new THREE.Vector2(x * size.x + child.position.x, z * size.z + child.position.z);
                                grassMeshes.push(child);
                            } 
                            else if (name.includes("colision") || name.includes("collision")) { child.visible = false; collisionMeshes.push(child); }
                            else if (name.includes("suelo")) { collisionMeshes.push(child); }
                        }
                    });
                }
            }
            // Iniciar hierba paramétrica
            setTimeout(() => { generateParametricGrass(); }, 500); 
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene; rawCharacterMesh.scale.set(0.7, 0.7, 0.7); rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group(); scene.add(playerContainer); playerContainer.position.set(0, 3, 0); 
            const box = new THREE.Box3().setFromObject(rawCharacterMesh); const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z); playerContainer.add(rawCharacterMesh);
            rawCharacterMesh.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; if(child.material) child.material.roughness = 0.8; } });
            if (gltf.animations && gltf.animations.length > 0) { mixer = new THREE.AnimationMixer(rawCharacterMesh); mixer.clipAction(gltf.animations[0]).play(); mixer.timeScale = 0; }
        });

        function jump() { if (isGrounded) { velocityY = jumpStrength; isGrounded = false; } }
        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8); const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        function shoot() { if (!playerContainer) return; const proj = new THREE.Mesh(projectileGeo, projectileMat); proj.position.copy(playerContainer.position).add(new THREE.Vector3(0,1.2,0)); const d = new THREE.Vector3(); playerContainer.getWorldDirection(d); proj.quaternion.copy(playerContainer.quaternion); proj.userData.velocity = d.multiplyScalar(projectileSpeed); proj.userData.lifeTime = 2.0; scene.add(proj); projectiles.push(proj); }
        
        function getEnvironmentHeight(pos) {
            const origin = pos.clone(); origin.y += 2.0; 
            raycaster.set(origin, downVector); raycaster.far = 20.0; 
            const hits = raycaster.intersectObjects(collisionMeshes, true); 
            if(hits.length > 0) return hits[0].point.y; 
            return -999;
        }
        function getPlayerHeight(pos) {
            const origin = pos.clone(); origin.y += 1.0; const offsets = [new THREE.Vector3(0,0,0), new THREE.Vector3(0.35,0,0), new THREE.Vector3(-0.35,0,0), new THREE.Vector3(0,0,0.35), new THREE.Vector3(0,0,-0.35)];
            let maxH = -999; let found = false;
            for(let o of offsets) { raycaster.set(origin.clone().add(o), downVector); raycaster.far = 10.0; const hits = raycaster.intersectObjects(collisionMeshes, true); if(hits.length > 0) { const y = hits[0].point.y; if(y > maxH) { maxH = y; found = true; }}}
            return found ? maxH : -999;
        }
        function checkWall(pos, dir) { raycaster.set(pos.clone().add(new THREE.Vector3(0,0.8,0)), dir); raycaster.far = 0.6; return raycaster.intersectObjects(collisionMeshes, true).length > 0; }

        function updatePhysics(dt) {
            if (!playerContainer) return;
            if (landingCooldown > 0) { landingCooldown -= dt; currentSpeed = 0; }
            let ix = joystickVector.x; let iy = joystickVector.y;
            if (keyStates.w) iy -= 1; if (keyStates.s) iy += 1; if (keyStates.a) ix -= 1; if (keyStates.d) ix += 1;
            moveDirection.set(ix, 0, iy); const len = moveDirection.length();
            if (len > 0.1 && landingCooldown <= 0) { isMoving = true; currentSpeed = (len > 1 ? maxMoveSpeed : maxMoveSpeed * len); } else { isMoving = false; if (landingCooldown <= 0) currentSpeed = 0; }
            if (isMoving) {
                const cf = new THREE.Vector3(); camera.getWorldDirection(cf); cf.y = 0; cf.normalize(); const cr = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), cf).normalize();
                const move = new THREE.Vector3().addScaledVector(cf, -moveDirection.z).addScaledVector(cr, -moveDirection.x).normalize();
                if (!checkWall(playerContainer.position, move)) playerContainer.position.addScaledVector(move, currentSpeed * dt);
                playerContainer.quaternion.slerp(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(move.x, move.z)), 10 * dt);
            }
            velocityY += gravity * dt; const propY = playerContainer.position.y + velocityY * dt; const floorY = getPlayerHeight(playerContainer.position);
            if (blobShadow) { blobShadow.visible = floorY > -500; if(blobShadow.visible) blobShadow.position.set(playerContainer.position.x, floorY + 0.05, playerContainer.position.z); }
            if (propY <= floorY && velocityY <= 0) { if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; playerContainer.position.y = floorY; velocityY = 0; isGrounded = true; } 
            else if (propY <= 0) { if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; playerContainer.position.y = 0; velocityY = 0; isGrounded = true; } 
            else { playerContainer.position.y = propY; isGrounded = false; }
        }

        function updateSmartCamera() {
            if (!playerContainer) return;
            const ideal = playerContainer.position.clone().add(new THREE.Vector3(camSettings.radius * Math.sin(camSettings.phi) * Math.sin(camSettings.theta), camSettings.radius * Math.cos(camSettings.phi), camSettings.radius * Math.sin(camSettings.phi) * Math.cos(camSettings.theta)));
            const head = playerContainer.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const dir = new THREE.Vector3().subVectors(ideal, head).normalize();
            cameraRaycaster.set(head, dir); cameraRaycaster.far = camSettings.radius;
            const hits = cameraRaycaster.intersectObjects(collisionMeshes, true);
            const dist = hits.length > 0 ? Math.max(camSettings.minRadius, hits[0].distance - 0.2) : camSettings.radius;
            camera.position.lerp(head.clone().add(dir.multiplyScalar(dist)), 0.2);
            camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); frames++; if (time >= lastTime + 1000) { fpsDisplay.innerText = "FPS: " + frames; frames = 0; lastTime = time; }
            let delta = Math.min(clock.getDelta(), 0.1); const elapsed = clock.getElapsedTime();

            const globalDir = new THREE.Vector3(1, 0, 0); 
            // ANIMACIÓN VIENTO (FIXED)
            for (let i = 0; i < grassMeshes.length; i++) {
                const mesh = grassMeshes[i]; 
                
                // --- CORRECCIÓN: Leer ops de mesh.userData (donde lo guardan ambos tipos)
                const ops = mesh.userData.originalPositions || (mesh.geometry.userData.originalPositions); 
                if(!ops) continue;

                const pos = mesh.geometry.attributes.position.array;
                
                // Si es hierba GLTF, tiene worldOffset. Si es paramétrica, su offset es 0 (está integrada en world)
                const wX = mesh.userData.worldOffset ? mesh.userData.worldOffset.x : mesh.position.x;
                
                // CALCULAR DIRECCIÓN LOCAL DEL VIENTO
                mesh.getWorldQuaternion(tempQuat);
                const inverseRot = tempQuat.invert();
                tempWindDir.copy(globalDir).applyQuaternion(inverseRot).normalize();
                
                const windX = tempWindDir.x; 
                const windZ = tempWindDir.z;

                for (let j = 0; j < ops.length; j += 3) {
                    const oy = ops[j+1]; 
                    if (oy <= 0.1) continue; 

                    const vGlobalX = ops[j] + wX;
                    const wave = (Math.sin(vGlobalX * 0.2 - elapsed * 3.0) + Math.cos(vGlobalX * 0.1 - elapsed * 2.1)) * 0.5;
                    const theta = wave * 0.5 * Math.pow(oy, 1.2); 

                    // Usar vector de viento local calculado
                    pos[j]   = ops[j]   + windX * Math.sin(theta) * oy;
                    pos[j+1] = ops[j+1] * Math.cos(theta); 
                    pos[j+2] = ops[j+2] + windZ * Math.sin(theta) * oy;
                }
                mesh.geometry.attributes.position.needsUpdate = true;
            }

            const steps = Math.min(4, Math.ceil(delta / (1/60))); for(let i=0; i<steps; i++) updatePhysics(delta/steps);

            if (playerContainer) {
                if (mixer) { mixer.timeScale = (isGrounded && isMoving) ? currentSpeed / maxMoveSpeed : 0; mixer.update(delta); }
                updateSmartCamera();
                sunLight.target.position.set(0, 0, playerContainer.position.z); sunLight.target.updateMatrixWorld(); sunLight.position.copy(sunLight.target.position).add(sunOffset);
                if (bgMesh) bgMesh.position.copy(camera.position);
            }
            for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.position.addScaledVector(p.userData.velocity, delta); p.userData.lifeTime -= delta; if (p.userData.lifeTime <= 0) { scene.remove(p); projectiles.splice(i, 1); }}

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>