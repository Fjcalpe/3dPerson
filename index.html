<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - Clustered Grass Fix</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #fps-display {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.5); color: #00ff00; 
            padding: 5px 10px; border-radius: 4px;
            font-family: monospace; font-weight: bold; font-size: 14px;
            pointer-events: none; z-index: 200;
        }

        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
        @media (max-width: 800px) { #pc-instructions { display: none; } }
        
        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 
        
        #error-log {
            position: absolute; top: 0; left: 0; background: red; color: white; padding: 5px; font-size: 10px; display: none; z-index: 9999;
        }
        /* Panel oculto */
        #debug-panel { display: none; }
    </style>
</head>
<body>
    <div id="fps-display">FPS: 0</div>
    <div id="error-log"></div>
    
    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.168.0",
                "three/addons/": "https://esm.sh/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        window.addEventListener('error', function(e) {
            const el = document.getElementById('error-log');
            el.style.display = 'block';
            el.innerHTML += "Error: " + e.message + "<br>";
        });

        // --- VARIABLES GLOBALES DE OPTIMIZACIÓN (Reutilización de memoria) ---
        // Crear vectores aquí fuera evita que el Garbage Collector salte cada frame
        const _tempVec3_1 = new THREE.Vector3();
        const _tempVec3_2 = new THREE.Vector3();
        const _tempVec3_3 = new THREE.Vector3();
        const globalWindDir = new THREE.Vector3(1, 0, 0);
        
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        let blobShadow;
        const clock = new THREE.Clock();
        
        let lastTime = performance.now();
        let frames = 0;
        const fpsDisplay = document.getElementById('fps-display');

        const collisionMeshes = [];
        let grassMeshes = []; 
        let parametricMesh = null; 
        
        const tempQuat = new THREE.Quaternion(); 
        const tempWindDir = new THREE.Vector3(); 
        
        // --- CONFIGURACIÓN HIERBA (5000 pero agrupada) ---
        const grassParams = {
            count: 5000,        // Bajada drástica para rendimiento
            width: 0.17,
            patches: 20,        // Número de "islas" de hierba
            patchRadius: 3.5,   // Tamaño de cada isla
            areaSize: 25,       // Area total del mapa
            color: '#ffcc00', 
            metalness: 0.95, 
            roughness: 0.1
        };

        const windParams = { strength: 1.1, speed: 3.0 };

        // --- FÍSICAS ---
        const maxMoveSpeed = 11.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;
        let velocityY = 0;
        const gravity = -50.0; 
        const jumpStrength = 18.0; 
        let isGrounded = false;
        let landingCooldown = 0.0; 
        const LANDING_PAUSE_DURATION = 0.2; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const projectiles = [];
        const projectileSpeed = 20.0;
        
        // --- ILUMINACIÓN ---
        const sunDistance = 50; 
        let sunOffset = new THREE.Vector3(); 
        let sunElevation = 13; 
        let sunRotation = 270; 
        const LIGHT_SETTINGS = { sunInt: 6.0, ambInt: 0.0, color: 0xffeeb1 };

        const keyStates = { w: false, a: false, s: false, d: false };
        const camSettings = { radius: 4.5, minRadius: 1.5, currentRadius: 4.5, theta: Math.PI, phi: 0.45 };
        const cameraRaycaster = new THREE.Raycaster();
        
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) { x = (x / distance) * maxRadius; y = (y / distance) * maxRadius; }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius; joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => { isDraggingJoystick = false; joystickVector = { x: 0, y: 0 }; joystickThumb.style.transform = `translate(0px, 0px)`; };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        document.addEventListener('pointerdown', (e) => { if (e.target.closest('.ui-element')) return; isDraggingCamera = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointermove', (e) => { if (!isDraggingCamera) return; const deltaX = e.clientX - previousMousePosition.x; const deltaY = e.clientY - previousMousePosition.y; camSettings.theta -= deltaX * 0.008; camSettings.phi -= deltaY * 0.008; camSettings.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camSettings.phi)); previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);
        document.addEventListener('keydown', (e) => { if(e.code==='KeyW') keyStates.w = true; if(e.code==='KeyS') keyStates.s = true; if(e.code==='KeyA') keyStates.a = true; if(e.code==='KeyD') keyStates.d = true; if(e.code==='Space') jump(); if(e.code==='KeyP') shoot(); });
        document.addEventListener('keyup', (e) => { if(e.code==='KeyW') keyStates.w = false; if(e.code==='KeyS') keyStates.s = false; if(e.code==='KeyA') keyStates.a = false; if(e.code==='KeyD') keyStates.d = false; });
        const jumpBtn = document.getElementById('btn-jump'); const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump)); jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot)); shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- INIT THREE ---
        const scene = new THREE.Scene();
        const fogColor = 0xeecfa1; const fogDensity = 0.022;
        scene.fog = new THREE.FogExp2(fogColor, fogDensity);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        // Desactivamos antialias en móvil por defecto para ganar rendimiento
        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.0 : 1.5)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 0.5; 
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        const bgTexture = textureLoader.load('./bg.webp', (texture) => { texture.colorSpace = THREE.SRGBColorSpace; });
        const iblTexture = textureLoader.load('./bg_reflejosIBL.webp', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.environment = texture; 
            scene.environmentIntensity = 2.0; 
            if(scene.environmentRotation) scene.environmentRotation.y = THREE.MathUtils.degToRad(334);
        });

        const shadowMat = new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1 });
        blobShadow = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), shadowMat);
        blobShadow.rotation.x = -Math.PI / 2; blobShadow.visible = false;
        scene.add(blobShadow);
        function createShadowTexture() { const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const ctx = canvas.getContext('2d'); const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(0,0,0,0.6)'); gradient.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64); return new THREE.CanvasTexture(canvas); }

        const sunLight = new THREE.DirectionalLight(LIGHT_SETTINGS.color, LIGHT_SETTINGS.sunInt);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(1024, 1024); // Sombra más ligera
        sunLight.shadow.radius = 2; 
        sunLight.shadow.bias = -0.0005; 
        sunLight.shadow.normalBias = 0.02;
        const d = 20; sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        scene.add(sunLight); scene.add(sunLight.target); 
        const hemiLight = new THREE.HemisphereLight(0xffd580, 0x222233, LIGHT_SETTINGS.ambInt);
        scene.add(hemiLight);

        function updateSun() {
            const phi = THREE.MathUtils.degToRad(90 - sunElevation); 
            const theta = THREE.MathUtils.degToRad(sunRotation);
            sunOffset.set(
                sunDistance * Math.sin(phi) * Math.sin(theta), 
                sunDistance * Math.cos(phi), 
                sunDistance * Math.sin(phi) * Math.cos(theta)
            );
        }
        updateSun(); 

        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false });
        sphereMat.color.setScalar(1.0);
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(123);
        scene.add(bgMesh);
        textureLoader.load('./Lightmap_Bake.webp', (t) => { t.flipY = false; t.channel = 1; }); 

        // --- GENERADOR HIERBA (POR PARCHES) ---
        function generateParametricGrass() {
            if (parametricMesh) {
                scene.remove(parametricMesh);
                const idx = grassMeshes.indexOf(parametricMesh);
                if (idx > -1) grassMeshes.splice(idx, 1);
                parametricMesh.geometry.dispose();
                parametricMesh.material.dispose();
                parametricMesh = null;
            }

            const count = grassParams.count; 
            const w = grassParams.width; 
            const h = 0.8; 
            
            // 1. GENERAR CENTROS DE PARCHES (CLUSTERS)
            const patches = [];
            for(let i=0; i<grassParams.patches; i++) {
                patches.push({
                    x: (Math.random() - 0.5) * grassParams.areaSize * 2,
                    z: (Math.random() - 0.5) * grassParams.areaSize * 2,
                    // Radio variable para que no sean círculos perfectos
                    r: grassParams.patchRadius * (0.8 + Math.random() * 0.4) 
                });
            }

            const positions = []; const colors = []; const indices = [];
            
            const mainColor = new THREE.Color(grassParams.color); const hsl = {}; mainColor.getHSL(hsl);
            const color1 = new THREE.Color().setHSL(hsl.h, hsl.s, Math.max(0, hsl.l - 0.15));
            const color2 = new THREE.Color().setHSL(hsl.h, hsl.s, Math.min(1, hsl.l + 0.1));
            const tempColor = new THREE.Color();

            for (let i = 0; i < count; i++) {
                // ELEGIR UN PARCHE AL AZAR
                const patch = patches[Math.floor(Math.random() * patches.length)];
                
                // Distribución aleatoria dentro del parche
                const angle = Math.random() * Math.PI * 2;
                // Raíz cuadrada para distribución uniforme en círculo
                const dist = Math.sqrt(Math.random()) * patch.r; 
                
                let x = patch.x + Math.cos(angle) * dist;
                let z = patch.z + Math.sin(angle) * dist;
                
                const y = getEnvironmentHeight(_tempVec3_1.set(x, 5, z));
                if (y < -100) continue; 

                const scaleY = 0.6 + Math.random() * 0.8; 
                const rotation = Math.random() * Math.PI * 2; 
                const finalH = h * scaleY;
                
                tempColor.lerpColors(color1, color2, Math.random());
                const cosR = Math.cos(rotation); const sinR = Math.sin(rotation);
                const transform = (lx, ly) => { return [x + lx * cosR, y + ly, z + lx * sinR]; };
                const vOffset = positions.length / 3;

                positions.push(...transform(-w/2, 0)); positions.push(...transform(w/2, 0));
                positions.push(...transform(-w/2 * 0.8, finalH * 0.33)); positions.push(...transform(w/2 * 0.8, finalH * 0.33));
                positions.push(...transform(-w/2 * 0.5, finalH * 0.66)); positions.push(...transform(w/2 * 0.5, finalH * 0.66));
                positions.push(...transform(0, finalH));

                const baseC = tempColor.clone().multiplyScalar(0.6); 
                colors.push(baseC.r, baseC.g, baseC.b); colors.push(baseC.r, baseC.g, baseC.b);
                colors.push(tempColor.r, tempColor.g, tempColor.b); colors.push(tempColor.r, tempColor.g, tempColor.b);
                colors.push(tempColor.r, tempColor.g, tempColor.b); colors.push(tempColor.r, tempColor.g, tempColor.b);
                const tipC = tempColor.clone().multiplyScalar(1.3); 
                colors.push(tipC.r, tipC.g, tipC.b);

                indices.push(vOffset, vOffset+1, vOffset+2); indices.push(vOffset+1, vOffset+3, vOffset+2);
                indices.push(vOffset+2, vOffset+3, vOffset+4); indices.push(vOffset+3, vOffset+5, vOffset+4);
                indices.push(vOffset+4, vOffset+5, vOffset+6);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            geometry.userData.originalPositions = geometry.attributes.position.array.slice();
            
            const material = new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                side: THREE.DoubleSide, 
                roughness: grassParams.roughness, 
                metalness: grassParams.metalness 
            });
            parametricMesh = new THREE.Mesh(geometry, material);
            parametricMesh.castShadow = true; 
            parametricMesh.receiveShadow = true;
            
            scene.add(parametricMesh);
            grassMeshes.push(parametricMesh);
        }

        const gltfLoader = new GLTFLoader();
        gltfLoader.load('./MN_SCENE_01.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const size = new THREE.Vector3(); new THREE.Box3().setFromObject(masterModule).getSize(size);
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    let moduleInstance = masterModule.clone(); moduleInstance.position.set(x * size.x, 0, z * size.z); scene.add(moduleInstance); 
                    moduleInstance.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true; child.receiveShadow = true; if (child.material) child.material.side = THREE.DoubleSide;
                            const name = child.name.toLowerCase();
                            if ((name.includes("hierba") || (child.parent && child.parent.name.toLowerCase().includes("hierba"))) && !name.includes("montes")) {
                                child.geometry = child.geometry.clone();
                                const posAttribute = child.geometry.attributes.position;
                                child.userData.originalPositions = posAttribute.array.slice(); 
                                child.userData.worldOffset = new THREE.Vector2(x * size.x + child.position.x, z * size.z + child.position.z);
                                grassMeshes.push(child);
                            } 
                            else if (name.includes("colision") || name.includes("collision")) { child.visible = false; collisionMeshes.push(child); }
                            else if (name.includes("suelo")) { collisionMeshes.push(child); }
                        }
                    });
                }
            }
            setTimeout(() => { generateParametricGrass(); }, 500); 
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene; rawCharacterMesh.scale.set(0.7, 0.7, 0.7); rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group(); scene.add(playerContainer); playerContainer.position.set(0, 3, 0); 
            const box = new THREE.Box3().setFromObject(rawCharacterMesh); const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z); playerContainer.add(rawCharacterMesh);
            rawCharacterMesh.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; if(child.material) child.material.roughness = 0.8; } });
            if (gltf.animations && gltf.animations.length > 0) { mixer = new THREE.AnimationMixer(rawCharacterMesh); mixer.clipAction(gltf.animations[0]).play(); mixer.timeScale = 0; }
        });

        function jump() { if (isGrounded) { velocityY = jumpStrength; isGrounded = false; } }
        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8); const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        function shoot() { if (!playerContainer) return; const proj = new THREE.Mesh(projectileGeo, projectileMat); proj.position.copy(playerContainer.position).add(new THREE.Vector3(0,1.2,0)); const d = new THREE.Vector3(); playerContainer.getWorldDirection(d); proj.quaternion.copy(playerContainer.quaternion); proj.userData.velocity = d.multiplyScalar(projectileSpeed); proj.userData.lifeTime = 2.0; scene.add(proj); projectiles.push(proj); }
        
        // --- OPTIMIZACIÓN: Reutilizar vector temporal ---
        function getEnvironmentHeight(pos) {
            _tempVec3_2.copy(pos).y += 2.0; // Usar vector temporal 2
            raycaster.set(_tempVec3_2, downVector); raycaster.far = 20.0; 
            const hits = raycaster.intersectObjects(collisionMeshes, true); 
            if(hits.length > 0) return hits[0].point.y; 
            return -999;
        }
        function getPlayerHeight(pos) {
            // Nota: Aquí mantenemos la lógica pero deberíamos optimizar offsets si fuera crítico
            const origin = pos.clone(); origin.y += 1.0; 
            const offsets = [new THREE.Vector3(0,0,0)]; // Simplificado a un rayo central para rendimiento
            let maxH = -999; let found = false;
            for(let o of offsets) { raycaster.set(origin.clone().add(o), downVector); raycaster.far = 10.0; const hits = raycaster.intersectObjects(collisionMeshes, true); if(hits.length > 0) { const y = hits[0].point.y; if(y > maxH) { maxH = y; found = true; }}}
            return found ? maxH : -999;
        }
        function checkWall(pos, dir) { raycaster.set(pos.clone().add(new THREE.Vector3(0,0.8,0)), dir); raycaster.far = 0.6; return raycaster.intersectObjects(collisionMeshes, true).length > 0; }

        function updatePhysics(dt) {
            if (!playerContainer) return;
            if (landingCooldown > 0) { landingCooldown -= dt; currentSpeed = 0; }
            let ix = joystickVector.x; let iy = joystickVector.y;
            if (keyStates.w) iy -= 1; if (keyStates.s) iy += 1; if (keyStates.a) ix -= 1; if (keyStates.d) ix += 1;
            
            // Reutilizar vector moveDirection (ya es global)
            moveDirection.set(ix, 0, iy); const len = moveDirection.length();
            if (len > 0.1 && landingCooldown <= 0) { isMoving = true; currentSpeed = (len > 1 ? maxMoveSpeed : maxMoveSpeed * len); } else { isMoving = false; if (landingCooldown <= 0) currentSpeed = 0; }
            
            if (isMoving) {
                // Reutilizar vectores temporales 1, 2, 3
                camera.getWorldDirection(_tempVec3_1); _tempVec3_1.y = 0; _tempVec3_1.normalize(); // cf
                _tempVec3_2.crossVectors(new THREE.Vector3(0, 1, 0), _tempVec3_1).normalize(); // cr (Nota: new Vector(0,1,0) es leve pero aceptable o se puede globalizar)
                
                // Move calculation
                _tempVec3_3.copy(_tempVec3_1).multiplyScalar(-moveDirection.z).addScaledVector(_tempVec3_2, -moveDirection.x).normalize();
                
                if (!checkWall(playerContainer.position, _tempVec3_3)) playerContainer.position.addScaledVector(_tempVec3_3, currentSpeed * dt);
                playerContainer.quaternion.slerp(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(_tempVec3_3.x, _tempVec3_3.z)), 10 * dt);
            }
            velocityY += gravity * dt; const propY = playerContainer.position.y + velocityY * dt; const floorY = getPlayerHeight(playerContainer.position);
            if (blobShadow) { blobShadow.visible = floorY > -500; if(blobShadow.visible) blobShadow.position.set(playerContainer.position.x, floorY + 0.05, playerContainer.position.z); }
            if (propY <= floorY && velocityY <= 0) { if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; playerContainer.position.y = floorY; velocityY = 0; isGrounded = true; } 
            else if (propY <= 0) { if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; playerContainer.position.y = 0; velocityY = 0; isGrounded = true; } 
            else { playerContainer.position.y = propY; isGrounded = false; }
        }

        function updateSmartCamera() {
            if (!playerContainer) return;
            const ideal = playerContainer.position.clone().add(new THREE.Vector3(camSettings.radius * Math.sin(camSettings.phi) * Math.sin(camSettings.theta), camSettings.radius * Math.cos(camSettings.phi), camSettings.radius * Math.sin(camSettings.phi) * Math.cos(camSettings.theta)));
            const head = playerContainer.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const dir = new THREE.Vector3().subVectors(ideal, head).normalize();
            cameraRaycaster.set(head, dir); cameraRaycaster.far = camSettings.radius;
            const hits = cameraRaycaster.intersectObjects(collisionMeshes, true);
            const dist = hits.length > 0 ? Math.max(camSettings.minRadius, hits[0].distance - 0.2) : camSettings.radius;
            camera.position.lerp(head.clone().add(dir.multiplyScalar(dist)), 0.2);
            camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); frames++; if (time >= lastTime + 1000) { fpsDisplay.innerText = "FPS: " + frames; frames = 0; lastTime = time; }
            let delta = Math.min(clock.getDelta(), 0.1); const elapsed = clock.getElapsedTime();

            // Animación Viento OPTIMIZADA (Sin news)
            for (let i = 0; i < grassMeshes.length; i++) {
                const mesh = grassMeshes[i]; 
                const ops = mesh.userData.originalPositions || (mesh.geometry.userData.originalPositions); 
                if(!ops) continue;

                const pos = mesh.geometry.attributes.position.array;
                const wX = mesh.userData.worldOffset ? mesh.userData.worldOffset.x : mesh.position.x;
                
                mesh.getWorldQuaternion(tempQuat); const inverseRot = tempQuat.invert();
                
                // Usamos globalWindDir pre-alocado
                tempWindDir.copy(globalWindDir).applyQuaternion(inverseRot).normalize();
                
                const windX = tempWindDir.x; const windZ = tempWindDir.z;

                for (let j = 0; j < ops.length; j += 3) {
                    const oy = ops[j+1]; if (oy <= 0.1) continue; 
                    const vGlobalX = ops[j] + wX;
                    const wave = (Math.sin(vGlobalX * 0.2 - elapsed * 3.0) + Math.cos(vGlobalX * 0.1 - elapsed * 2.1)) * 0.5;
                    const theta = wave * 0.5 * Math.pow(oy, 1.2); 
                    pos[j]   = ops[j]   + windX * Math.sin(theta) * oy;
                    pos[j+1] = ops[j+1] * Math.cos(theta); 
                    pos[j+2] = ops[j+2] + windZ * Math.sin(theta) * oy;
                }
                mesh.geometry.attributes.position.needsUpdate = true;
            }

            updatePhysics(delta); // Un solo paso de física

            if (playerContainer) {
                if (mixer) { mixer.timeScale = (isGrounded && isMoving) ? currentSpeed / maxMoveSpeed : 0; mixer.update(delta); }
                updateSmartCamera();
                sunLight.target.position.set(0, 0, playerContainer.position.z); sunLight.target.updateMatrixWorld(); sunLight.position.copy(sunLight.target.position).add(sunOffset);
                if (bgMesh) bgMesh.position.copy(camera.position);
            }
            for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.position.addScaledVector(p.userData.velocity, delta); p.userData.lifeTime -= delta; if (p.userData.lifeTime <= 0) { scene.remove(p); projectiles.splice(i, 1); }}

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>