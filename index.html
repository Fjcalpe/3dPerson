<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - Clean UI</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #fps-display {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.5); color: #00ff00; 
            padding: 5px 10px; border-radius: 4px;
            font-family: monospace; font-weight: bold; font-size: 14px;
            pointer-events: none; z-index: 200;
        }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
        
        #error-log {
            position: absolute; top: 40px; left: 0; background: red; color: white; padding: 5px; font-size: 10px; display: none; z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="fps-display">FPS: 0</div>
    
    <div id="error-log"></div>
    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.168.0",
                "three/addons/": "https://esm.sh/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        window.addEventListener('error', function(e) {
            const el = document.getElementById('error-log');
            el.style.display = 'block';
            el.innerHTML += "Error: " + e.message + "<br>";
        });

        const _tempVec3_1 = new THREE.Vector3();
        const _tempVec3_2 = new THREE.Vector3();
        const _tempVec3_3 = new THREE.Vector3();
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        let blobShadow;
        const clock = new THREE.Clock();
        let lastTime = performance.now();
        let frames = 0;
        const fpsDisplay = document.getElementById('fps-display');

        const collisionMeshes = [];
        let parametricMesh = null;
        
        let grassSource = { geometry: null, material: null, scale: new THREE.Vector3(1,1,1) };
        let grassMaterialUniforms = { time: { value: 0 } }; 

        // --- PARÁMETROS FIJOS (GUARDADOS DE LA IMAGEN) ---
        const grassParams = {
            count: 11000,   // Valor de la imagen
            areaSize: 20,   // Valor de la imagen
            patches: 85,    // Valor de la imagen
            patchRadius: 4.5 
        };

        const maxMoveSpeed = 11.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;
        let velocityY = 0;
        const gravity = -50.0; 
        const jumpStrength = 18.0; 
        let isGrounded = false;
        let landingCooldown = 0.0; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const projectiles = [];
        
        const keyStates = { w: false, a: false, s: false, d: false };
        const camSettings = { radius: 4.5, minRadius: 1.5, currentRadius: 4.5, theta: Math.PI, phi: 0.45 };
        const cameraRaycaster = new THREE.Raycaster();
        
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) { x = (x / distance) * maxRadius; y = (y / distance) * maxRadius; }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius; joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => { isDraggingJoystick = false; joystickVector = { x: 0, y: 0 }; joystickThumb.style.transform = `translate(0px, 0px)`; };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        document.addEventListener('pointerdown', (e) => { if (e.target.closest('.ui-element')) return; isDraggingCamera = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointermove', (e) => { if (!isDraggingCamera) return; const deltaX = e.clientX - previousMousePosition.x; const deltaY = e.clientY - previousMousePosition.y; camSettings.theta -= deltaX * 0.008; camSettings.phi -= deltaY * 0.008; camSettings.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camSettings.phi)); previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);
        document.addEventListener('keydown', (e) => { if(e.code==='KeyW') keyStates.w = true; if(e.code==='KeyS') keyStates.s = true; if(e.code==='KeyA') keyStates.a = true; if(e.code==='KeyD') keyStates.d = true; if(e.code==='Space') jump(); if(e.code==='KeyP') shoot(); });
        document.addEventListener('keyup', (e) => { if(e.code==='KeyW') keyStates.w = false; if(e.code==='KeyS') keyStates.s = false; if(e.code==='KeyA') keyStates.a = false; if(e.code==='KeyD') keyStates.d = false; });
        const jumpBtn = document.getElementById('btn-jump'); const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump)); jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot)); shootBtn.addEventListener('mousedown', triggerAction(shoot));

        const scene = new THREE.Scene();
        const fogColor = 0xeecfa1; const fogDensity = 0.022;
        scene.fog = new THREE.FogExp2(fogColor, fogDensity);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.0 : 1.5)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 0.5; 
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        
        const bgTexture = textureLoader.load('./bg.webp', (texture) => { texture.colorSpace = THREE.SRGBColorSpace; });
        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false });
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(123);
        scene.add(bgMesh);

        textureLoader.load('./bg_reflejosIBL.webp', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.environment = texture; 
            scene.environmentIntensity = 2.0; 
            if(scene.environmentRotation) scene.environmentRotation.y = THREE.MathUtils.degToRad(334);
        });

        const shadowMat = new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1 });
        blobShadow = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), shadowMat);
        blobShadow.rotation.x = -Math.PI / 2; blobShadow.visible = false;
        scene.add(blobShadow);
        function createShadowTexture() { const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const ctx = canvas.getContext('2d'); const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(0,0,0,0.6)'); gradient.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64); return new THREE.CanvasTexture(canvas); }

        const sunDistance = 50; 
        let sunOffset = new THREE.Vector3(); 
        let sunElevation = 13; 
        let sunRotation = 270; 

        function updateSun() {
            const phi = THREE.MathUtils.degToRad(90 - sunElevation); 
            const theta = THREE.MathUtils.degToRad(sunRotation);
            sunOffset.set(
                sunDistance * Math.sin(phi) * Math.sin(theta), 
                sunDistance * Math.cos(phi), 
                sunDistance * Math.sin(phi) * Math.cos(theta)
            );
        }
        updateSun();

        const sunLight = new THREE.DirectionalLight(0xffeeb1, 6.0);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048); 
        sunLight.shadow.camera.left = -20; sunLight.shadow.camera.right = 20; sunLight.shadow.camera.top = 20; sunLight.shadow.camera.bottom = -20;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150;
        sunLight.shadow.bias = -0.0005; 
        sunLight.shadow.normalBias = 0.05; 
        
        scene.add(sunLight); scene.add(sunLight.target); 
        scene.add(new THREE.HemisphereLight(0xffd580, 0x222233, 0.5));

        function modifyMaterialForWind(material) {
            const newMat = material.clone();
            newMat.onBeforeCompile = (shader) => {
                shader.uniforms.time = grassMaterialUniforms.time;
                
                shader.vertexShader = `
                    uniform float time;
                    ${shader.vertexShader}
                `;
                
                // --- VIENTO INVERTIDO 180 GRADOS ---
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    #include <begin_vertex>
                    
                    float h = max(0.0, transformed.y); 

                    float worldX = instanceMatrix[3][0] + transformed.x;
                    float worldZ = instanceMatrix[3][2] + transformed.z;
                    
                    float windWave = sin(time * 3.0 - worldX * 0.5 + worldZ * 0.2);
                    float bend = windWave * -0.25 * h * h; 

                    vec3 localWindDir = normalize(vec3(instanceMatrix[0].x, instanceMatrix[1].x, instanceMatrix[2].x));
                    
                    transformed += localWindDir * bend;
                    
                    vec3 localCrossDir = normalize(vec3(instanceMatrix[0].z, instanceMatrix[1].z, instanceMatrix[2].z));
                    transformed += localCrossDir * bend * 0.2;
                    `
                );
            };
            newMat.customProgramCacheKey = () => 'windyGrassInverted';
            return newMat;
        }

        function generateInstancedGrass() {
            if (parametricMesh) {
                scene.remove(parametricMesh);
                parametricMesh.dispose(); 
                parametricMesh = null;
            }

            if (!grassSource.geometry || !grassSource.material) return;

            const count = grassParams.count;
            const windMaterial = modifyMaterialForWind(grassSource.material);
            
            parametricMesh = new THREE.InstancedMesh(grassSource.geometry, windMaterial, count);
            parametricMesh.castShadow = true;
            parametricMesh.receiveShadow = true;
            parametricMesh.frustumCulled = false; 

            const dummy = new THREE.Object3D();
            const patches = [];
            for(let i=0; i<grassParams.patches; i++) {
                patches.push({
                    x: (Math.random() - 0.5) * grassParams.areaSize * 2,
                    z: (Math.random() - 0.5) * grassParams.areaSize * 2,
                    r: grassParams.patchRadius * (0.8 + Math.random() * 0.4) 
                });
            }

            let index = 0;
            for (let i = 0; i < count; i++) {
                const patch = patches[Math.floor(Math.random() * patches.length)];
                const angle = Math.random() * Math.PI * 2;
                
                const dist = Math.random() * patch.r; 
                
                let x = patch.x + Math.cos(angle) * dist;
                let z = patch.z + Math.sin(angle) * dist;
                
                _tempVec3_1.set(x, 10, z);
                const y = getEnvironmentHeight(_tempVec3_1);
                
                if (y < -100) {
                    dummy.position.set(0, -9999, 0);
                    dummy.updateMatrix();
                    parametricMesh.setMatrixAt(index++, dummy.matrix);
                    continue; 
                }

                dummy.position.set(x, y, z);
                dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);
                
                const distanceFactor = dist / patch.r; 
                const sizeFalloff = Math.max(0.01, 1.0 - Math.pow(distanceFactor, 1.5));
                const randomBaseScale = 0.6 + Math.random() * 0.6;
                const finalScale = randomBaseScale * sizeFalloff;

                dummy.scale.set(
                    grassSource.scale.x * finalScale, 
                    grassSource.scale.y * finalScale * (0.7 + Math.random()*0.5), 
                    grassSource.scale.z * finalScale
                );
                
                dummy.updateMatrix();
                parametricMesh.setMatrixAt(index++, dummy.matrix);
            }
            
            parametricMesh.instanceMatrix.needsUpdate = true;
            scene.add(parametricMesh);
            console.log(`Hierba: ${count}, Parches: ${grassParams.patches}, Área: ${grassParams.areaSize}`);
        }

        const gltfLoader = new GLTFLoader();
        gltfLoader.load('./MN_SCENE_01.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const size = new THREE.Vector3(); new THREE.Box3().setFromObject(masterModule).getSize(size);
            
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    let moduleInstance = masterModule.clone(); 
                    moduleInstance.position.set(x * size.x, 0, z * size.z); 
                    scene.add(moduleInstance); 
                    
                    moduleInstance.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true; 
                            child.receiveShadow = true; 
                            const name = child.name.toLowerCase();
                            
                            if (name.includes("hierba_b")) {
                                if (!grassSource.geometry) {
                                    grassSource.geometry = child.geometry.clone(); 
                                    grassSource.material = child.material; 
                                    grassSource.scale.copy(child.scale); 
                                }
                                child.visible = false; 
                                return;
                            }

                            if (name.includes("colision") || name.includes("collision") || name.includes("suelo")) {
                                collisionMeshes.push(child);
                                if(name.includes("colision")) child.visible = false;
                            }
                        }
                    });
                }
            }
            
            setTimeout(() => { 
                if(grassSource.geometry) {
                    generateInstancedGrass(); 
                } else {
                    console.error("No se encontró 'hierba_B'.");
                }
            }, 500); 
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene; rawCharacterMesh.scale.set(0.7, 0.7, 0.7); 
            playerContainer = new THREE.Group(); scene.add(playerContainer); playerContainer.position.set(0, 3, 0); 
            const box = new THREE.Box3().setFromObject(rawCharacterMesh); const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z); playerContainer.add(rawCharacterMesh);
            rawCharacterMesh.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
            if (gltf.animations && gltf.animations.length > 0) { mixer = new THREE.AnimationMixer(rawCharacterMesh); mixer.clipAction(gltf.animations[0]).play(); mixer.timeScale = 0; }
        });

        function jump() { if (isGrounded) { velocityY = jumpStrength; isGrounded = false; } }
        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8); const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        function shoot() { if (!playerContainer) return; const proj = new THREE.Mesh(projectileGeo, projectileMat); proj.position.copy(playerContainer.position).add(new THREE.Vector3(0,1.2,0)); const d = new THREE.Vector3(); playerContainer.getWorldDirection(d); proj.quaternion.copy(playerContainer.quaternion); proj.userData.velocity = d.multiplyScalar(20); proj.userData.lifeTime = 2.0; scene.add(proj); projectiles.push(proj); }
        
        function getEnvironmentHeight(pos) {
            _tempVec3_2.copy(pos).y += 5.0; 
            raycaster.set(_tempVec3_2, downVector); raycaster.far = 30.0; 
            const hits = raycaster.intersectObjects(collisionMeshes, true); 
            if(hits.length > 0) return hits[0].point.y; 
            return -999;
        }
        function getPlayerHeight(pos) {
            const origin = pos.clone(); origin.y += 1.0; 
            raycaster.set(origin, downVector); raycaster.far = 10.0; 
            const hits = raycaster.intersectObjects(collisionMeshes, true); 
            return hits.length > 0 ? hits[0].point.y : -999;
        }
        function checkWall(pos, dir) { raycaster.set(pos.clone().add(new THREE.Vector3(0,0.8,0)), dir); raycaster.far = 0.6; return raycaster.intersectObjects(collisionMeshes, true).length > 0; }

        function updatePhysics(dt) {
            if (!playerContainer) return;
            if (landingCooldown > 0) { landingCooldown -= dt; currentSpeed = 0; }
            let ix = joystickVector.x; let iy = joystickVector.y;
            if (keyStates.w) iy -= 1; if (keyStates.s) iy += 1; if (keyStates.a) ix -= 1; if (keyStates.d) ix += 1;
            
            moveDirection.set(ix, 0, iy); const len = moveDirection.length();
            if (len > 0.1 && landingCooldown <= 0) { isMoving = true; currentSpeed = (len > 1 ? maxMoveSpeed : maxMoveSpeed * len); } else { isMoving = false; if (landingCooldown <= 0) currentSpeed = 0; }
            
            if (isMoving) {
                camera.getWorldDirection(_tempVec3_1); _tempVec3_1.y = 0; _tempVec3_1.normalize(); 
                _tempVec3_2.crossVectors(new THREE.Vector3(0, 1, 0), _tempVec3_1).normalize(); 
                _tempVec3_3.copy(_tempVec3_1).multiplyScalar(-moveDirection.z).addScaledVector(_tempVec3_2, -moveDirection.x).normalize();
                
                if (!checkWall(playerContainer.position, _tempVec3_3)) playerContainer.position.addScaledVector(_tempVec3_3, currentSpeed * dt);
                playerContainer.quaternion.slerp(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(_tempVec3_3.x, _tempVec3_3.z)), 10 * dt);
            }
            velocityY += gravity * dt; const propY = playerContainer.position.y + velocityY * dt; const floorY = getPlayerHeight(playerContainer.position);
            if (blobShadow) { blobShadow.visible = floorY > -500; if(blobShadow.visible) blobShadow.position.set(playerContainer.position.x, floorY + 0.05, playerContainer.position.z); }
            if (propY <= floorY && velocityY <= 0) { if (!isGrounded) landingCooldown = 0.2; playerContainer.position.y = floorY; velocityY = 0; isGrounded = true; } 
            else if (propY <= 0) { if (!isGrounded) landingCooldown = 0.2; playerContainer.position.y = 0; velocityY = 0; isGrounded = true; } 
            else { playerContainer.position.y = propY; isGrounded = false; }
        }

        function updateSmartCamera() {
            if (!playerContainer) return;
            const ideal = playerContainer.position.clone().add(new THREE.Vector3(camSettings.radius * Math.sin(camSettings.phi) * Math.sin(camSettings.theta), camSettings.radius * Math.cos(camSettings.phi), camSettings.radius * Math.sin(camSettings.phi) * Math.cos(camSettings.theta)));
            const head = playerContainer.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const dir = new THREE.Vector3().subVectors(ideal, head).normalize();
            cameraRaycaster.set(head, dir); cameraRaycaster.far = camSettings.radius;
            const hits = cameraRaycaster.intersectObjects(collisionMeshes, true);
            const dist = hits.length > 0 ? Math.max(camSettings.minRadius, hits[0].distance - 0.2) : camSettings.radius;
            camera.position.lerp(head.clone().add(dir.multiplyScalar(dist)), 0.2);
            camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); frames++; if (time >= lastTime + 1000) { fpsDisplay.innerText = "FPS: " + frames; frames = 0; lastTime = time; }
            let delta = Math.min(clock.getDelta(), 0.1); 
            
            grassMaterialUniforms.time.value = clock.getElapsedTime();

            if(playerContainer) {
                sunLight.target.position.set(0, 0, playerContainer.position.z);
                sunLight.target.updateMatrixWorld();
                sunLight.position.copy(sunLight.target.position).add(sunOffset);
                if (bgMesh) bgMesh.position.copy(camera.position);
            }

            const steps = Math.min(isMobile ? 2 : 4, Math.ceil(delta / (1/60))); 
            for(let i=0; i<steps; i++) updatePhysics(delta/steps);

            if (playerContainer) {
                if (mixer) { mixer.timeScale = (isGrounded && isMoving) ? currentSpeed / maxMoveSpeed : 0; mixer.update(delta); }
                updateSmartCamera();
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) { 
                const p = projectiles[i]; 
                p.position.addScaledVector(p.userData.velocity, delta); 
                p.userData.lifeTime -= delta; 
                if (p.userData.lifeTime <= 0) { scene.remove(p); projectiles.splice(i, 1); }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        });
        
        animate();
    </script>
</body>
</html>