<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Juego 3D - Mobile Touch</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: sans-serif;
            touch-action: none; /* Previene zoom/scroll al tocar */
            user-select: none;
            -webkit-user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 10;
        }

        /* --- ESTILOS DE LOS BOTONES TÁCTILES --- */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }

        .control-row {
            display: flex;
            justify-content: center;
        }

        .touch-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: background 0.1s;
            touch-action: none; /* Importante para móviles */
        }

        .touch-btn:active, .touch-btn.active {
            background: rgba(255, 238, 177, 0.5); /* Color dorado al pulsar */
            transform: scale(0.95);
        }

        /* Espaciador para la fila del medio (A - D) */
        .spacer {
            width: 70px; 
            height: 70px; 
            margin: 5px;
        }

    </style>
</head>
<body>
    <div id="info">Controles Táctiles Activados</div>

    <div id="mobile-controls">
        <div class="control-row">
            <div class="touch-btn" id="btn-w">W</div>
        </div>
        <div class="control-row">
            <div class="touch-btn" id="btn-a">A</div>
            <div class="touch-btn" id="btn-s">S</div>
            <div class="touch-btn" id="btn-d">D</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- VARIABLES GLOBALES ---
        let mixer; 
        let playerContainer; 
        const clock = new THREE.Clock();
        
        const moveSpeed = 5.0;
        const rotationSpeed = 8.0; 

        // Vector para la luz
        let sunOffset = new THREE.Vector3(); 

        // Estado de Inputs (Teclado + Touch compartidos)
        const keyStates = { KeyW: false, KeyA: false, KeyS: false, KeyD: false };

        // 1. ESCENA
        const scene = new THREE.Scene();
        const atmosphereColor = 0x110800; 
        scene.background = new THREE.Color(atmosphereColor);
        scene.fog = new THREE.Fog(atmosphereColor, 10, 60); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; 
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        // 2. INPUTS (TECLADO + TOUCH)
        
        // Teclado (para depurar en PC)
        document.addEventListener('keydown', (e) => { if(keyStates.hasOwnProperty(e.code)) keyStates[e.code] = true; });
        document.addEventListener('keyup', (e) => { if(keyStates.hasOwnProperty(e.code)) keyStates[e.code] = false; });

        // Función auxiliar para asignar eventos touch
        function assignTouch(elementId, keyCode) {
            const el = document.getElementById(elementId);
            
            // Eventos Touch (Móvil)
            el.addEventListener('touchstart', (e) => { 
                e.preventDefault(); // Evita scroll
                keyStates[keyCode] = true; 
                el.classList.add('active'); // Feedback visual
            }, { passive: false });
            
            el.addEventListener('touchend', (e) => { 
                e.preventDefault();
                keyStates[keyCode] = false; 
                el.classList.remove('active');
            }, { passive: false });

            // Eventos Ratón (Para probar en PC con clicks)
            el.addEventListener('mousedown', (e) => {
                keyStates[keyCode] = true;
                el.classList.add('active');
            });
            el.addEventListener('mouseup', (e) => {
                keyStates[keyCode] = false;
                el.classList.remove('active');
            });
            el.addEventListener('mouseleave', (e) => {
                 keyStates[keyCode] = false;
                 el.classList.remove('active');
            });
        }

        assignTouch('btn-w', 'KeyW');
        assignTouch('btn-a', 'KeyA');
        assignTouch('btn-s', 'KeyS');
        assignTouch('btn-d', 'KeyD');


        // 3. ILUMINACIÓN (VALORES FIJOS DEFINITIVOS)
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        const FIXED_SETTINGS = {
            vert: 35,
            horiz: 215,
            intensity: 3.3,
            amb: 1.05,
            color: 0xffeeb1
        };

        const sunLight = new THREE.DirectionalLight(FIXED_SETTINGS.color, FIXED_SETTINGS.intensity); 
        sunLight.castShadow = true;
        
        // Configuración de sombras PRO (la que arreglamos antes)
        sunLight.shadow.mapSize.set(4096, 4096); 
        const d = 50; 
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 150; 
        sunLight.shadow.bias = -0.0001; 
        sunLight.shadow.normalBias = 0.02; 

        scene.add(sunLight);
        scene.add(sunLight.target); 

        const hemiLight = new THREE.HemisphereLight(FIXED_SETTINGS.color, 0x000000, FIXED_SETTINGS.amb);
        scene.add(hemiLight);

        // Calculamos el offset de luz una sola vez
        const sunDistance = 50;
        const phi = THREE.MathUtils.degToRad(90 - FIXED_SETTINGS.vert); 
        const theta = THREE.MathUtils.degToRad(FIXED_SETTINGS.horiz);   
        sunOffset.set(
            sunDistance * Math.sin(phi) * Math.sin(theta),
            sunDistance * Math.cos(phi),
            sunDistance * Math.sin(phi) * Math.cos(theta)
        );


        // 4. CARGA DE ASSETS
        const loader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();

        const lightmapTexture = textureLoader.load('./Lightmap_Bake.webp');
        lightmapTexture.flipY = false; 
        lightmapTexture.channel = 1; 

        loader.load('./modulo_1.gltf', function (gltf) {
            const originalModule = gltf.scene;
            const box = new THREE.Box3().setFromObject(originalModule);
            const size = new THREE.Vector3();
            box.getSize(size);

            originalModule.traverse((child) => {
                if (child.isMesh) {
                    child.material.lightMap = lightmapTexture;
                    child.material.lightMapIntensity = 1.0; 
                    child.material.aoMap = lightmapTexture;
                    child.material.aoMapIntensity = 1.0;
                    child.material.envMapIntensity = 0.1; 
                    child.material.side = THREE.DoubleSide;
                    child.castShadow = true; 
                    child.receiveShadow = true;
                }
            });

            const numberOfModules = 12; // Un poco más de pasillo
            for (let i = 0; i < numberOfModules; i++) {
                let moduleInstance;
                if (i === 0) moduleInstance = originalModule;
                else moduleInstance = originalModule.clone();
                moduleInstance.position.z = - (i * size.z);
                scene.add(moduleInstance);
            }
            addDecoLights(originalModule, size.z);
        });

        loader.load('./GIRLrun.gltf', function (gltf) {
            const rawMesh = gltf.scene;
            playerContainer = new THREE.Group();
            playerContainer.position.set(0, 0, 0);
            scene.add(playerContainer);

            const box = new THREE.Box3().setFromObject(rawMesh);
            const center = box.getCenter(new THREE.Vector3());
            const bottomY = box.min.y;

            rawMesh.position.x = -center.x;
            rawMesh.position.z = -center.z;
            rawMesh.position.y = -bottomY; 

            playerContainer.add(rawMesh);

            rawMesh.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(rawMesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
                mixer.timeScale = 0; 
            }
        });

        function addDecoLights(module, lengthZ) {
             const positions = [
                { x: -3.8, z: -lengthZ * 0.20 },
                { x:  3.8, z: -lengthZ * 0.20 },
                { x: -3.8, z: -lengthZ * 0.80 },
                { x:  3.8, z: -lengthZ * 0.80 }
            ];
            const bulbMat = new THREE.MeshBasicMaterial({ color: 0xccffff });
            const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8);
            positions.forEach(pos => {
                const bulb = new THREE.Mesh(bulbGeo, bulbMat);
                bulb.position.set(pos.x, 2.9, pos.z); 
                module.add(bulb);
            });
        }

        // 5. ANIMACIÓN
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (playerContainer) {
                const direction = new THREE.Vector3(0, 0, 0);

                if (keyStates['KeyW']) direction.z -= 1;
                if (keyStates['KeyS']) direction.z += 1;
                if (keyStates['KeyA']) direction.x -= 1;
                if (keyStates['KeyD']) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();
                    playerContainer.position.addScaledVector(direction, moveSpeed * delta);

                    const targetAngle = Math.atan2(direction.x, direction.z);
                    const targetQuaternion = new THREE.Quaternion();
                    targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    playerContainer.quaternion.slerp(targetQuaternion, rotationSpeed * delta);

                    if (mixer) mixer.timeScale = 1.0;
                } else {
                    if (mixer) mixer.timeScale = 0;
                }

                // Luz sigue al jugador
                sunLight.target.position.set(0, 0, playerContainer.position.z);
                sunLight.target.updateMatrixWorld();
                sunLight.position.copy(sunLight.target.position).add(sunOffset);

                // Cámara
                const cameraOffset = new THREE.Vector3(0, 3.5, 3.0);
                const targetCamPos = playerContainer.position.clone().add(cameraOffset);
                camera.position.lerp(targetCamPos, 0.25);
                camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.4, playerContainer.position.z);
            }

            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>