<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Juego 3D - Golden Corridor</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="info">Escenario: Luz Dorada Frontal + Bake Cian</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // 1. ESCENA
        const scene = new THREE.Scene();
        // Atmósfera dorada/marrón
        const atmosphereColor = 0x110800; 
        scene.background = new THREE.Color(atmosphereColor);
        scene.fog = new THREE.Fog(atmosphereColor, 15, 60); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2.5, 8); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; 
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        // 2. ILUMINACIÓN
        
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        // --- SOL DORADO (Posición ajustada) ---
        const sunLight = new THREE.DirectionalLight(0xffaa33, 3.0); 
        
        // NUEVA POSICIÓN:
        // x: -15 (Ligeramente a la izquierda)
        // y: 10  (Bajo, pero suficiente para saltar el primer muro)
        // z: 40  (Muy atrás de la cámara, para iluminar hacia adelante)
        sunLight.position.set(-15, 10, 40); 
        
        sunLight.castShadow = true;
        
        // Optimizamos la caja de sombras para que sea larga y estrecha, cubriendo el pasillo
        sunLight.shadow.mapSize.set(2048, 2048); 
        sunLight.shadow.camera.left = -20;
        sunLight.shadow.camera.right = 20;
        sunLight.shadow.camera.top = 20;
        sunLight.shadow.camera.bottom = -10;
        sunLight.shadow.camera.far = 100; // Aseguramos que llegue al fondo
        sunLight.shadow.bias = -0.0005;

        scene.add(sunLight);

        // Luz de relleno cálida tenue
        const hemiLight = new THREE.HemisphereLight(0xffaa33, 0x000000, 0.1);
        scene.add(hemiLight);


        // 3. CARGA
        const loader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();

        const lightmapTexture = textureLoader.load('./Lightmap_Bake.webp');
        lightmapTexture.flipY = false; 
        lightmapTexture.channel = 1; 

        loader.load(
            './modulo_1.gltf', 
            function (gltf) {
                const originalModule = gltf.scene;
                const box = new THREE.Box3().setFromObject(originalModule);
                const size = new THREE.Vector3();
                box.getSize(size);

                originalModule.traverse((child) => {
                    if (child.isMesh) {
                        // Lightmap (Bake Cian)
                        child.material.lightMap = lightmapTexture;
                        child.material.lightMapIntensity = 1.0; 
                        child.material.aoMap = lightmapTexture;
                        child.material.aoMapIntensity = 1.0;
                        child.material.envMapIntensity = 0.1; 
                        child.material.side = THREE.DoubleSide;

                        // Sombras dinámicas para el Sol
                        child.castShadow = true; 
                        child.receiveShadow = true;
                    }
                });

                // CLONADO
                const numberOfModules = 3; 
                for (let i = 0; i < numberOfModules; i++) {
                    let moduleInstance;
                    if (i === 0) moduleInstance = originalModule;
                    else moduleInstance = originalModule.clone();

                    moduleInstance.position.z = - (i * size.z);
                    moduleInstance.updateMatrix();
                    moduleInstance.matrixAutoUpdate = false;
                    scene.add(moduleInstance);
                }
                
                addDecoLights(originalModule, size.z);

                document.getElementById('info').innerText = "Pasillo iluminado por el sol poniente.";
            },
            undefined,
            function (error) { console.error(error); }
        );

        function addDecoLights(module, lengthZ) {
             const positions = [
                { x: -3.8, z: -lengthZ * 0.20 },
                { x:  3.8, z: -lengthZ * 0.20 },
                { x: -3.8, z: -lengthZ * 0.80 },
                { x:  3.8, z: -lengthZ * 0.80 }
            ];
            const bulbMat = new THREE.MeshBasicMaterial({ color: 0xccffff });
            const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8);

            positions.forEach(pos => {
                const bulb = new THREE.Mesh(bulbGeo, bulbMat);
                bulb.position.set(pos.x, 2.9, pos.z); 
                module.add(bulb);
            });
        }

        // 4. ANIMACIÓN
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, -10); // Miramos más al fondo

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>