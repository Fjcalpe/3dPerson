<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - Bloom HQ & AA</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #fps-display {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.5); color: #00ff00; 
            padding: 5px 10px; border-radius: 4px;
            font-family: monospace; font-weight: bold; font-size: 14px;
            pointer-events: none; z-index: 200;
        }

        #debug-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7); color: white;
            padding: 15px; border-radius: 8px;
            z-index: 200; width: 240px;
            max-height: 90vh; overflow-y: auto; 
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .panel-section { margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .section-title { font-size: 11px; text-transform: uppercase; color: #ffeb3b; margin-bottom: 8px; letter-spacing: 1px; font-weight: bold;}
        
        .control-group { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;}
        .control-group.slider-group { display: block; }
        .control-group label { font-size: 12px; color: #ccc; }
        .control-group input[type=range] { width: 100%; cursor: pointer; accent-color: #ffeb3b; display: block; margin-top: 4px;}
        .control-group input[type=checkbox] { cursor: pointer; accent-color: #ffeb3b; transform: scale(1.2); }
        .value-display { float: right; color: #ffeb3b; font-weight: bold; font-size: 12px; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
        
        #error-log {
            position: absolute; top: 0; left: 0; background: red; color: white; padding: 5px; font-size: 10px; display: none; z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="fps-display">FPS: 0</div>
    <div id="error-log"></div>
    
    <div id="debug-panel">
        <div class="panel-section">
            <div class="section-title">Calidad Gráfica</div>
            <div class="control-group">
                <label>ACTIVAR BLOOM</label>
                <input type="checkbox" id="input-bloom-toggle" checked>
            </div>
            <div class="control-group">
                <label>ANTIALIAS (FXAA)</label>
                <input type="checkbox" id="input-aa-toggle" checked>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">Ajustes Bloom</div>
            <div class="control-group slider-group">
                <label>Intensidad <span id="val-bloom-str" class="value-display">0.4</span></label>
                <input type="range" id="input-bloom-str" min="0" max="3.0" step="0.1" value="0.4">
            </div>
            <div class="control-group slider-group">
                <label>Radio <span id="val-bloom-rad" class="value-display">0.5</span></label>
                <input type="range" id="input-bloom-rad" min="0" max="2.0" step="0.1" value="0.5">
            </div>
            <div class="control-group slider-group">
                <label>Umbral (Threshold) <span id="val-bloom-thr" class="value-display">0.85</span></label>
                <input type="range" id="input-bloom-thr" min="0" max="1.0" step="0.05" value="0.85">
            </div>
        </div>
    </div>

    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.168.0",
                "three/addons/": "https://esm.sh/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // --- IMPORTS POST-PROCESADO ---
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // Error catcher
        window.addEventListener('error', function(e) {
            const el = document.getElementById('error-log');
            el.style.display = 'block';
            el.innerHTML += "Error: " + e.message + "<br>";
        });

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        let blobShadow, composer, bloomPass, fxaaPass;
        const clock = new THREE.Clock();
        
        // FPS
        let lastTime = performance.now();
        let frames = 0;
        const fpsDisplay = document.getElementById('fps-display');

        const collisionMeshes = [];
        const grassMeshes = []; 
        const tempQuat = new THREE.Quaternion(); 
        const tempWindDir = new THREE.Vector3(); 
        const windParams = { strength: 1.1, speed: 3.0 };

        // --- FÍSICAS ---
        const maxMoveSpeed = 11.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;
        let velocityY = 0;
        const gravity = -50.0; 
        const jumpStrength = 18.0; 
        let isGrounded = false;
        let landingCooldown = 0.0; 
        const LANDING_PAUSE_DURATION = 0.2; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const projectiles = [];
        const projectileSpeed = 20.0;
        
        // --- PARÁMETROS FIJOS ---
        const FIXED_SETTINGS = { 
            bgRot: 123, iblRot: 334, sunRot: 270, 
            sunInt: 6.0, ambInt: 0.0, iblInt: 2.0,
            exposure: 0.5, skyBright: 1.0, color: 0xffeeb1 
        };
        const sunDistance = 50; 
        let sunOffset = new THREE.Vector3(); 

        const keyStates = { w: false, a: false, s: false, d: false };
        const camSettings = { radius: 4.5, minRadius: 1.5, currentRadius: 4.5, theta: Math.PI, phi: 0.45 };
        const cameraRaycaster = new THREE.Raycaster();
        
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        // --- INPUTS ---
        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) { x = (x / distance) * maxRadius; y = (y / distance) * maxRadius; }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius; joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => { isDraggingJoystick = false; joystickVector = { x: 0, y: 0 }; joystickThumb.style.transform = `translate(0px, 0px)`; };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        document.addEventListener('pointerdown', (e) => { if (e.target.closest('.ui-element') || e.target.closest('#debug-panel')) return; isDraggingCamera = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointermove', (e) => { if (!isDraggingCamera) return; const deltaX = e.clientX - previousMousePosition.x; const deltaY = e.clientY - previousMousePosition.y; camSettings.theta -= deltaX * 0.008; camSettings.phi -= deltaY * 0.008; camSettings.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camSettings.phi)); previousMousePosition = { x: e.clientX, y: e.clientY }; });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);
        document.addEventListener('keydown', (e) => { if(e.code==='KeyW') keyStates.w = true; if(e.code==='KeyS') keyStates.s = true; if(e.code==='KeyA') keyStates.a = true; if(e.code==='KeyD') keyStates.d = true; if(e.code==='Space') jump(); if(e.code==='KeyP') shoot(); });
        document.addEventListener('keyup', (e) => { if(e.code==='KeyW') keyStates.w = false; if(e.code==='KeyS') keyStates.s = false; if(e.code==='KeyA') keyStates.a = false; if(e.code==='KeyD') keyStates.d = false; });
        const jumpBtn = document.getElementById('btn-jump'); const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump)); jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot)); shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- INIT THREE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Usar ratio nativo para máxima nitidez
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = FIXED_SETTINGS.exposure; 
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        // --- COMPOSER CONFIGURATION (BLOOM + FXAA) ---
        try {
            const renderScene = new RenderPass(scene, camera);
            
            // 1. CONFIGURACIÓN ALTA RESOLUCIÓN BLOOM
            // Usamos la resolución real del dispositivo para evitar cuadros
            const pixelRatio = renderer.getPixelRatio();
            const width = window.innerWidth * pixelRatio;
            const height = window.innerHeight * pixelRatio;
            const bloomRes = new THREE.Vector2(width, height);
            
            bloomPass = new UnrealBloomPass(bloomRes, 1.5, 0.4, 0.85);
            bloomPass.strength = 0.4;
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.85;

            // 2. OUTPUT PASS (Tone Mapping & Color Correction)
            const outputPass = new OutputPass();

            // 3. FXAA PASS (Antialias)
            fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(1 / (window.innerWidth * pixelRatio), 1 / (window.innerHeight * pixelRatio));

            composer = new EffectComposer(renderer);
            composer.setPixelRatio(pixelRatio); // Importante para EffectComposer
            composer.setSize(window.innerWidth, window.innerHeight);
            
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);
            composer.addPass(fxaaPass);
            
        } catch (err) {
            console.error("Composer Init Error", err);
        }

        // --- ENVIRONMENT ---
        const textureLoader = new THREE.TextureLoader();
        const bgTexture = textureLoader.load('./bg.webp', (texture) => { texture.colorSpace = THREE.SRGBColorSpace; });
        const iblTexture = textureLoader.load('./bg_reflejosIBL.webp', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.environment = texture; 
            scene.environmentIntensity = FIXED_SETTINGS.iblInt; 
            if(scene.environmentRotation) scene.environmentRotation.y = THREE.MathUtils.degToRad(FIXED_SETTINGS.iblRot);
        });

        const shadowMat = new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1 });
        blobShadow = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), shadowMat);
        blobShadow.rotation.x = -Math.PI / 2; blobShadow.visible = false;
        scene.add(blobShadow);
        function createShadowTexture() { const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64; const ctx = canvas.getContext('2d'); const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32); gradient.addColorStop(0, 'rgba(0,0,0,0.6)'); gradient.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64); return new THREE.CanvasTexture(canvas); }

        // --- LIGHTS ---
        const sunLight = new THREE.DirectionalLight(FIXED_SETTINGS.color, FIXED_SETTINGS.sunInt);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(1024, 1024); sunLight.shadow.radius = 3; 
        const d = 20; sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        
        const phiSun = THREE.MathUtils.degToRad(90 - 35); 
        const thetaSun = THREE.MathUtils.degToRad(FIXED_SETTINGS.sunRot); 
        sunOffset.set(sunDistance * Math.sin(phiSun) * Math.sin(thetaSun), sunDistance * Math.cos(phiSun), sunDistance * Math.sin(phiSun) * Math.cos(thetaSun));
        scene.add(sunLight); scene.add(sunLight.target); 
        
        const hemiLight = new THREE.HemisphereLight(0xffd580, 0x222233, FIXED_SETTINGS.ambInt);
        scene.add(hemiLight);

        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false });
        sphereMat.color.setScalar(FIXED_SETTINGS.skyBright);
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(FIXED_SETTINGS.bgRot);
        scene.add(bgMesh);

        textureLoader.load('./Lightmap_Bake.webp', (t) => { t.flipY = false; t.channel = 1; }); 

        // --- CONTROLES UI ACTUALIZADOS ---
        document.getElementById('input-bloom-toggle').addEventListener('change', (e) => { 
            if(bloomPass) bloomPass.enabled = e.target.checked; 
        });
        
        document.getElementById('input-aa-toggle').addEventListener('change', (e) => { 
            if(fxaaPass) fxaaPass.enabled = e.target.checked; 
        });

        document.getElementById('input-bloom-str').addEventListener('input', (e) => { const val = parseFloat(e.target.value); document.getElementById('val-bloom-str').innerText = val.toFixed(1); if(bloomPass) bloomPass.strength = val; });
        document.getElementById('input-bloom-rad').addEventListener('input', (e) => { const val = parseFloat(e.target.value); document.getElementById('val-bloom-rad').innerText = val.toFixed(1); if(bloomPass) bloomPass.radius = val; });
        document.getElementById('input-bloom-thr').addEventListener('input', (e) => { const val = parseFloat(e.target.value); document.getElementById('val-bloom-thr').innerText = val.toFixed(2); if(bloomPass) bloomPass.threshold = val; });

        // --- ASSETS ---
        const gltfLoader = new GLTFLoader();

        gltfLoader.load('./MN_SCENE_01.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const size = new THREE.Vector3(); new THREE.Box3().setFromObject(masterModule).getSize(size);
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    let moduleInstance = masterModule.clone(); moduleInstance.position.set(x * size.x, 0, z * size.z); scene.add(moduleInstance); 
                    moduleInstance.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true; child.receiveShadow = true; if (child.material) child.material.side = THREE.DoubleSide;
                            const name = child.name.toLowerCase();
                            if ((name.includes("hierba") || (child.parent && child.parent.name.toLowerCase().includes("hierba"))) && !name.includes("montes")) {
                                child.geometry = child.geometry.clone();
                                child.userData.originalPositions = child.geometry.attributes.position.array.slice(); 
                                child.userData.worldOffset = new THREE.Vector2(x * size.x + child.position.x, z * size.z + child.position.z);
                                grassMeshes.push(child);
                            } else if (name.includes("colision") || name.includes("collision")) { child.visible = false; collisionMeshes.push(child); }
                            else if (name.includes("suelo")) { collisionMeshes.push(child); }
                        }
                    });
                }
            }
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene; rawCharacterMesh.scale.set(0.7, 0.7, 0.7); rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group(); scene.add(playerContainer); playerContainer.position.set(0, 3, 0); 
            const box = new THREE.Box3().setFromObject(rawCharacterMesh); const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z); playerContainer.add(rawCharacterMesh);
            rawCharacterMesh.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; if(child.material) child.material.roughness = 0.8; } });
            if (gltf.animations && gltf.animations.length > 0) { mixer = new THREE.AnimationMixer(rawCharacterMesh); mixer.clipAction(gltf.animations[0]).play(); mixer.timeScale = 0; }
        });

        // --- GAME LOGIC ---
        function jump() { if (isGrounded) { velocityY = jumpStrength; isGrounded = false; } }
        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8); const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        function shoot() { if (!playerContainer) return; const proj = new THREE.Mesh(projectileGeo, projectileMat); proj.position.copy(playerContainer.position).add(new THREE.Vector3(0,1.2,0)); const d = new THREE.Vector3(); playerContainer.getWorldDirection(d); proj.quaternion.copy(playerContainer.quaternion); proj.userData.velocity = d.multiplyScalar(projectileSpeed); proj.userData.lifeTime = 2.0; scene.add(proj); projectiles.push(proj); }
        function getEnvironmentHeight(pos) {
            const origin = pos.clone(); origin.y += 1.0; 
            const offsets = [new THREE.Vector3(0,0,0), new THREE.Vector3(0.35,0,0), new THREE.Vector3(-0.35,0,0), new THREE.Vector3(0,0,0.35), new THREE.Vector3(0,0,-0.35)];
            let maxH = -999; let found = false;
            for(let o of offsets) { raycaster.set(origin.clone().add(o), downVector); raycaster.far = 10.0; const hits = raycaster.intersectObjects(collisionMeshes, true); if(hits.length > 0) { const y = hits[0].point.y; if(y > maxH) { maxH = y; found = true; }}}
            return found ? maxH : -999;
        }
        function checkWall(pos, dir) { raycaster.set(pos.clone().add(new THREE.Vector3(0,0.8,0)), dir); raycaster.far = 0.6; return raycaster.intersectObjects(collisionMeshes, true).length > 0; }

        function updatePhysics(dt) {
            if (!playerContainer) return;
            if (landingCooldown > 0) { landingCooldown -= dt; currentSpeed = 0; }
            let ix = joystickVector.x; let iy = joystickVector.y;
            if (keyStates.w) iy -= 1; if (keyStates.s) iy += 1; if (keyStates.a) ix -= 1; if (keyStates.d) ix += 1;
            moveDirection.set(ix, 0, iy); const len = moveDirection.length();
            if (len > 0.1 && landingCooldown <= 0) { isMoving = true; currentSpeed = (len > 1 ? maxMoveSpeed : maxMoveSpeed * len); } else { isMoving = false; if (landingCooldown <= 0) currentSpeed = 0; }
            if (isMoving) {
                const cf = new THREE.Vector3(); camera.getWorldDirection(cf); cf.y = 0; cf.normalize();
                const cr = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), cf).normalize();
                const move = new THREE.Vector3().addScaledVector(cf, -moveDirection.z).addScaledVector(cr, -moveDirection.x).normalize();
                if (!checkWall(playerContainer.position, move)) playerContainer.position.addScaledVector(move, currentSpeed * dt);
                playerContainer.quaternion.slerp(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(move.x, move.z)), 10 * dt);
            }
            velocityY += gravity * dt; const propY = playerContainer.position.y + velocityY * dt; const floorY = getEnvironmentHeight(playerContainer.position);
            if (blobShadow) { blobShadow.visible = floorY > -500; if(blobShadow.visible) blobShadow.position.set(playerContainer.position.x, floorY + 0.05, playerContainer.position.z); }
            if (propY <= floorY && velocityY <= 0) { if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; playerContainer.position.y = floorY; velocityY = 0; isGrounded = true; } 
            else if (propY <= 0) { if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; playerContainer.position.y = 0; velocityY = 0; isGrounded = true; } 
            else { playerContainer.position.y = propY; isGrounded = false; }
        }

        function updateSmartCamera() {
            if (!playerContainer) return;
            const ideal = playerContainer.position.clone().add(new THREE.Vector3(camSettings.radius * Math.sin(camSettings.phi) * Math.sin(camSettings.theta), camSettings.radius * Math.cos(camSettings.phi), camSettings.radius * Math.sin(camSettings.phi) * Math.cos(camSettings.theta)));
            const head = playerContainer.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const dir = new THREE.Vector3().subVectors(ideal, head).normalize();
            cameraRaycaster.set(head, dir); cameraRaycaster.far = camSettings.radius;
            const hits = cameraRaycaster.intersectObjects(collisionMeshes, true);
            const dist = hits.length > 0 ? Math.max(camSettings.minRadius, hits[0].distance - 0.2) : camSettings.radius;
            camera.position.lerp(head.clone().add(dir.multiplyScalar(dist)), 0.2);
            camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); frames++; if (time >= lastTime + 1000) { fpsDisplay.innerText = "FPS: " + frames; frames = 0; lastTime = time; }
            let delta = Math.min(clock.getDelta(), 0.1); const elapsed = clock.getElapsedTime();

            const globalDir = new THREE.Vector3(1, 0, 0); 
            for (let i = 0; i < grassMeshes.length; i++) {
                const mesh = grassMeshes[i]; const ops = mesh.userData.originalPositions; const pos = mesh.geometry.attributes.position.array;
                const wx = mesh.userData.worldOffset ? mesh.userData.worldOffset.x : mesh.position.x;
                mesh.getWorldQuaternion(tempQuat); const idir = tempWindDir.copy(globalDir).applyQuaternion(tempQuat.invert()).normalize();
                for (let j = 0; j < ops.length; j += 3) {
                    const oy = ops[j+1]; if (oy <= 0.1) continue;
                    const wave = (Math.sin((wx+ops[j])*0.2 - elapsed*3 + (Math.sin((wx+ops[j])*0.5)*1.5)) + Math.cos((wx+ops[j])*0.1 - elapsed*2.1) + 1.5) * 0.5;
                    const theta = wave * 1.1 * Math.pow(oy, 0.75) * 0.7;
                    pos[j] = ops[j] + idir.x * Math.sin(theta) * oy * 1.3; pos[j+1] = oy * (Math.cos(theta) * 0.7 + 0.3); pos[j+2] = ops[j+2] + idir.z * Math.sin(theta) * oy * 1.3;
                }
                mesh.geometry.attributes.position.needsUpdate = true;
            }

            const steps = Math.min(4, Math.ceil(delta / (1/60))); for(let i=0; i<steps; i++) updatePhysics(delta/steps);

            if (playerContainer) {
                if (mixer) { mixer.timeScale = (isGrounded && isMoving) ? currentSpeed / maxMoveSpeed : 0; mixer.update(delta); }
                updateSmartCamera();
                sunLight.target.position.set(0, 0, playerContainer.position.z); sunLight.target.updateMatrixWorld(); sunLight.position.copy(sunLight.target.position).add(sunOffset);
                if (bgMesh) bgMesh.position.copy(camera.position);
            }
            for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.position.addScaledVector(p.userData.velocity, delta); p.userData.lifeTime -= delta; if (p.userData.lifeTime <= 0) { scene.remove(p); projectiles.splice(i, 1); }}

            // RENDERING
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        window.addEventListener('resize', () => { 
            const newPixelRatio = window.devicePixelRatio;
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(newPixelRatio);

            if(composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
                composer.setPixelRatio(newPixelRatio);
                
                // Actualizar resolución Bloom y FXAA al redimensionar
                if(bloomPass) {
                    bloomPass.resolution.set(window.innerWidth * newPixelRatio, window.innerHeight * newPixelRatio);
                }
                if(fxaaPass) {
                    fxaaPass.uniforms['resolution'].value.set(1 / (window.innerWidth * newPixelRatio), 1 / (window.innerHeight * newPixelRatio));
                }
            }
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>