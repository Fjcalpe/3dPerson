<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - AA + Res 1.2</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #settings-ui {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.85); color: #00ff00; 
            padding: 10px; border-radius: 4px;
            text-align: right; z-index: 200; font-family: monospace;
            border: 1px solid #00ff00;
            min-width: 180px;
        }
        #settings-ui label { font-size: 13px; display: flex; justify-content: flex-end; align-items: center; margin-bottom: 8px; color: white; cursor: pointer; }
        #settings-ui input[type=checkbox] { margin-left: 8px; transform: scale(1.2); }
        
        #fps-display {
            font-size: 18px; font-weight: bold; color: #ffff00; margin-bottom: 12px;
            border-bottom: 1px solid #555; padding-bottom: 5px; text-align: center;
        }

        .divider { border: 0; border-top: 1px solid #555; margin: 8px 0; }
        .stat-row { font-size: 11px; color: #aaa; margin-bottom: 4px; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>
    
    <div id="settings-ui" class="ui-element">
        <div id="fps-display">FPS: 0</div>
        
        <label title="Resolución alta (1.2x) o baja (0.7x). Baja para ganar FPS.">
            Resolución HD <input type="checkbox" id="res-toggle" checked>
        </label>
        
        <label title="Activa o desactiva las sombras del sol.">
            Sombras <input type="checkbox" id="shadows-toggle" checked>
        </label>
        
        <label title="Calidad del mapa de sombras (1024px vs 512px).">
            Sombras HQ <input type="checkbox" id="shadows-hq-toggle" checked>
        </label>

        <hr class="divider">
        <div class="stat-row">Physics Steps: <span id="phys-steps">1</span></div>
        <div class="stat-row">Triángulos: <span id="tri-count">0</span></div>
        
        <hr class="divider">
        <label>
            Ver Rayos Debug <input type="checkbox" id="collider-debug">
        </label>
    </div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        let blobShadow;
        const clock = new THREE.Clock();
        
        // FPS Variables
        let lastTime = performance.now();
        let frames = 0;
        const fpsDisplay = document.getElementById('fps-display');
        const physStepsDisplay = document.getElementById('phys-steps');
        const uiTriCount = document.getElementById('tri-count');

        // Optimización
        const environmentMeshes = [];

        // --- FÍSICAS "ATLETA" (Analogicas) ---
        const maxMoveSpeed = 11.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;

        let velocityY = 0;
        const gravity = -50.0; 
        const jumpStrength = 18.0; 
        let isGrounded = false;

        // SISTEMA DE COLISIONES (RAYCAST)
        const collisionMeshes = []; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        let groundArrow, wallArrow;

        const projectiles = [];
        const projectileSpeed = 20.0;

        let sunOffset = new THREE.Vector3(); 
        const FIXED_SETTINGS = { vert: 35, horiz: 215, intensity: 3.0, amb: 0.4, color: 0xffeeb1 };
        const keyStates = { w: false, a: false, s: false, d: false };

        // CÁMARA
        const defaultCamData = { radius: 3.2, theta: 0.00, phi: 0.60 };
        let camRadius = defaultCamData.radius;
        let camTheta = defaultCamData.theta;
        let camPhi = defaultCamData.phi;
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };

        // --- CONTROLES UI ---
        const resToggle = document.getElementById('res-toggle');
        const shadowsToggle = document.getElementById('shadows-toggle');
        const shadowsHqToggle = document.getElementById('shadows-hq-toggle');
        const colliderDebugToggle = document.getElementById('collider-debug');

        resToggle.addEventListener('change', (e) => {
            const isHD = e.target.checked;
            // CAMBIO: 1.2 si HD, 0.7 si Low
            const ratio = isHD ? Math.min(window.devicePixelRatio, 1.2) : 0.7;
            renderer.setPixelRatio(ratio);
        });

        shadowsToggle.addEventListener('change', (e) => {
            const isOn = e.target.checked;
            sunLight.castShadow = isOn;
            environmentMeshes.forEach(m => m.castShadow = isOn);
            if (playerContainer) playerContainer.traverse(c => { if(c.isMesh) c.castShadow = isOn; });
        });

        shadowsHqToggle.addEventListener('change', (e) => {
            const isHQ = e.target.checked;
            const size = isHQ ? 1024 : 512;
            if (sunLight && sunLight.shadow) {
                sunLight.shadow.mapSize.set(size, size);
                if(sunLight.shadow.map) {
                    sunLight.shadow.map.dispose();
                    sunLight.shadow.map = null;
                }
            }
        });

        colliderDebugToggle.addEventListener('change', (e) => {
            const show = e.target.checked;
            if(groundArrow) groundArrow.visible = show;
            if(wallArrow) wallArrow.visible = show;
            collisionMeshes.forEach(mesh => {
                if(mesh.userData.isCollider) {
                    mesh.material.visible = show;
                    mesh.material.wireframe = true;
                }
            });
        });

        document.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.ui-element')) return;
            isDraggingCamera = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointermove', (e) => {
            if (!isDraggingCamera) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            camTheta -= deltaX * 0.005; 
            camPhi -= deltaY * 0.005;
            camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPhi));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);

        // Joystick
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) {
                x = (x / distance) * maxRadius;
                y = (y / distance) * maxRadius;
            }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            
            joystickVector.x = x / maxRadius;
            joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => {
            isDraggingJoystick = false;
            joystickVector = { x: 0, y: 0 };
            joystickThumb.style.transform = `translate(0px, 0px)`;
        };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        // Inputs
        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW') keyStates.w = true;
            if(e.code==='KeyS') keyStates.s = true;
            if(e.code==='KeyA') keyStates.a = true;
            if(e.code==='KeyD') keyStates.d = true;
            if(e.code==='Space') jump();
            if(e.code==='KeyP') shoot();
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW') keyStates.w = false;
            if(e.code==='KeyS') keyStates.s = false;
            if(e.code==='KeyA') keyStates.a = false;
            if(e.code==='KeyD') keyStates.d = false;
        });

        const jumpBtn = document.getElementById('btn-jump');
        const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump));
        jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot));
        shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        
        // --- CAMBIOS SOLICITADOS: AA True, Ratio 1.2 ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2)); 
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envTexture = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.environment = envTexture;
        scene.environmentIntensity = 0.5; 

        // Debug Arrows
        groundArrow = new THREE.ArrowHelper(downVector, new THREE.Vector3(), 1, 0x00ff00);
        wallArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 1, 0xff0000);
        groundArrow.visible = false;
        wallArrow.visible = false;
        scene.add(groundArrow);
        scene.add(wallArrow);

        // BLOB SHADOW
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0,0,0,0.6)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        
        const shadowMat = new THREE.MeshBasicMaterial({ 
            map: createShadowTexture(), 
            transparent: true, 
            depthWrite: false, 
            polygonOffset: true, polygonOffsetFactor: -1 
        });
        const shadowGeo = new THREE.PlaneGeometry(0.8, 0.8);
        blobShadow = new THREE.Mesh(shadowGeo, shadowMat);
        blobShadow.rotation.x = -Math.PI / 2; 
        blobShadow.visible = false;
        scene.add(blobShadow);

        // LUZ SOL
        const sunLight = new THREE.DirectionalLight(FIXED_SETTINGS.color, FIXED_SETTINGS.intensity); 
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(1024, 1024); 
        sunLight.shadow.radius = 3; 
        
        const d = 20; 
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        
        sunLight.shadow.bias = -0.001;  
        sunLight.shadow.normalBias = 0.05; 
        scene.add(sunLight); scene.add(sunLight.target); 
        
        const hemiLight = new THREE.HemisphereLight(FIXED_SETTINGS.color, 0x000000, FIXED_SETTINGS.amb);
        scene.add(hemiLight);

        const sunDistance = 50;
        const phiSun = THREE.MathUtils.degToRad(90 - FIXED_SETTINGS.vert); 
        const thetaSun = THREE.MathUtils.degToRad(FIXED_SETTINGS.horiz);   
        sunOffset.set(sunDistance * Math.sin(phiSun) * Math.sin(thetaSun), sunDistance * Math.cos(phiSun), sunDistance * Math.sin(phiSun) * Math.cos(thetaSun));

        const gltfLoader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();
        
        // FONDO
        const bgTexture = textureLoader.load('./bg.webp');
        bgTexture.colorSpace = THREE.SRGBColorSpace; 
        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); 
        sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ 
            map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false 
        });
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(58);
        scene.add(bgMesh);

        // --- PLATAFORMAS FLOTANTES ---
        function addPlatform(x, y, z) {
            const geo = new THREE.BoxGeometry(2.5, 0.2, 2.5); 
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.frustumCulled = false; 
            scene.add(mesh);
            collisionMeshes.push(mesh);
            environmentMeshes.push(mesh);
        }

        addPlatform(0, 2.0, -15);
        addPlatform(-2, 3.5, -22);
        addPlatform(2, 5.0, -30);

        const lightmapTexture = textureLoader.load('./Lightmap_Bake.webp');
        lightmapTexture.flipY = false; lightmapTexture.channel = 1; 
        
        // --- CARGAR MÓDULO ---
        gltfLoader.load('./modulo_1.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const totalBox = new THREE.Box3().setFromObject(masterModule);
            const size = new THREE.Vector3();
            totalBox.getSize(size);

            for (let i = 0; i < 6; i++) { 
                let moduleInstance = masterModule.clone(); 
                let zPos = - (i * size.z);
                moduleInstance.position.z = zPos;
                scene.add(moduleInstance); 

                moduleInstance.traverse((child) => {
                    const nameLower = child.name.toLowerCase();
                    if (nameLower.includes("colision") || nameLower.includes("collision")) {
                        child.material = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000, wireframe: true, transparent: true, opacity: 0.0, side: THREE.DoubleSide
                        });
                        child.userData.isCollider = true;
                        child.visible = true; 
                        collisionMeshes.push(child);
                    } else if (child.isMesh) {
                        child.material.lightMap = lightmapTexture; 
                        child.material.lightMapIntensity = 1.0; 
                        child.material.aoMap = lightmapTexture; 
                        child.material.aoMapIntensity = 1.0; 
                        child.material.envMapIntensity = 0.1; 
                        child.material.side = THREE.DoubleSide; 
                        
                        child.castShadow = true; 
                        child.receiveShadow = true; 
                        
                        environmentMeshes.push(child);
                    }
                });
            }
            addDecoLights(masterModule, size.z);
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene;
            rawCharacterMesh.scale.set(0.7, 0.7, 0.7);
            rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group();
            scene.add(playerContainer);
            playerContainer.position.set(0, 5, 0); 
            
            const box = new THREE.Box3().setFromObject(rawCharacterMesh);
            const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z);
            playerContainer.add(rawCharacterMesh);
            
            rawCharacterMesh.traverse((child) => { 
                if (child.isMesh) { 
                    child.castShadow = true; 
                    child.receiveShadow = true; 
                    if(child.material) child.material.roughness = 0.8; 
                }
            });
            
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(rawCharacterMesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
                mixer.timeScale = 0; 
            }
        });

        function addDecoLights(module, lengthZ) { const positions = [ { x: -3.8, z: -lengthZ * 0.20 }, { x:  3.8, z: -lengthZ * 0.20 }, { x: -3.8, z: -lengthZ * 0.80 }, { x:  3.8, z: -lengthZ * 0.80 } ]; const bulbMat = new THREE.MeshBasicMaterial({ color: 0xccffff }); const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8); positions.forEach(pos => { const bulb = new THREE.Mesh(bulbGeo, bulbMat); bulb.position.set(pos.x, 2.9, pos.z); module.add(bulb); }); }

        function jump() {
            if (isGrounded) { velocityY = jumpStrength; isGrounded = false; }
        }

        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
        const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        
        function shoot() {
            if (!playerContainer) return;
            const proj = new THREE.Mesh(projectileGeo, projectileMat);
            proj.position.copy(playerContainer.position);
            proj.position.y += 1.2; 
            const direction = new THREE.Vector3();
            playerContainer.getWorldDirection(direction); 
            proj.quaternion.copy(playerContainer.quaternion);
            proj.userData.velocity = direction.multiplyScalar(projectileSpeed);
            proj.userData.lifeTime = 2.0; 
            scene.add(proj);
            projectiles.push(proj);
        }

        // --- SISTEMA FÍSICO RAYCAST MULTIPLE (BIG FEET) ---
        function getEnvironmentHeight(position) {
            const origin = position.clone();
            origin.y += 1.0; 
            
            const footRadius = 0.35; 
            const offsets = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(footRadius, 0, 0),
                new THREE.Vector3(-footRadius, 0, 0),
                new THREE.Vector3(0, 0, footRadius),
                new THREE.Vector3(0, 0, -footRadius)
            ];

            let maxHeight = -999;
            let hitFound = false;

            for(let i=0; i<offsets.length; i++) {
                const rayOrigin = origin.clone().add(offsets[i]);
                raycaster.set(rayOrigin, downVector);
                raycaster.far = 10.0; 
                
                const intersects = raycaster.intersectObjects(collisionMeshes, true);
                if (intersects.length > 0) {
                    const hitY = intersects[0].point.y;
                    if (hitY > maxHeight) {
                        maxHeight = hitY;
                        hitFound = true;
                    }
                }
            }

            if (groundArrow) { groundArrow.position.copy(origin); groundArrow.setDirection(downVector); }
            
            return hitFound ? maxHeight : -999;
        }

        function checkWall(position, direction) {
            const origin = position.clone();
            origin.y += 0.8; 
            if (wallArrow) { wallArrow.position.copy(origin); wallArrow.setDirection(direction); }
            raycaster.set(origin, direction);
            raycaster.far = 0.6; 
            const intersects = raycaster.intersectObjects(collisionMeshes, true);
            return intersects.length > 0;
        }

        function updatePhysics(dt) {
            if (!playerContainer) return;

            let inputX = joystickVector.x;
            let inputY = joystickVector.y;
            if (keyStates.w) inputY -= 1;
            if (keyStates.s) inputY += 1;
            if (keyStates.a) inputX -= 1;
            if (keyStates.d) inputX += 1;

            moveDirection.set(inputX, 0, inputY);
            const length = moveDirection.length();
            
            if (length > 0.1) { 
                isMoving = true;
                if (length > 1) { 
                    moveDirection.normalize(); 
                    currentSpeed = maxMoveSpeed; 
                } else { 
                    currentSpeed = maxMoveSpeed * length; 
                }
            } else {
                isMoving = false;
                currentSpeed = 0;
            }

            if (isMoving) {
                const worldDirection = moveDirection.clone();
                if (!checkWall(playerContainer.position, worldDirection)) {
                    playerContainer.position.addScaledVector(moveDirection, currentSpeed * dt);
                }
                const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                const targetQuaternion = new THREE.Quaternion();
                targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                playerContainer.quaternion.slerp(targetQuaternion, 10 * dt);
            }

            velocityY += gravity * dt;
            let proposedY = playerContainer.position.y + velocityY * dt;
            const floorY = getEnvironmentHeight(playerContainer.position);
            
            if (blobShadow) {
                if (floorY > -500) {
                    blobShadow.visible = true;
                    blobShadow.position.set(playerContainer.position.x, floorY + 0.05, playerContainer.position.z);
                } else {
                    blobShadow.visible = false;
                }
            }

            if (proposedY <= floorY && velocityY <= 0) {
                playerContainer.position.y = floorY;
                velocityY = 0;
                isGrounded = true;
            } else if (proposedY <= 0) {
                playerContainer.position.y = 0;
                velocityY = 0;
                isGrounded = true;
            } else {
                playerContainer.position.y = proposedY;
                isGrounded = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            frames++;
            if (time >= lastTime + 1000) {
                fpsDisplay.innerText = "FPS: " + frames;
                frames = 0;
                lastTime = time;
                if(renderer.info.render) uiTriCount.innerText = renderer.info.render.triangles.toLocaleString();
            }

            let delta = Math.min(clock.getDelta(), 0.1); 
            
            const timeStep = 1/60; 
            let steps = Math.ceil(delta / timeStep);
            if(steps > 4) steps = 4; 
            
            physStepsDisplay.innerText = steps; 

            for(let i=0; i<steps; i++) {
                updatePhysics(delta / steps);
            }

            if (playerContainer) {
                if (mixer) {
                    if (isGrounded && isMoving) mixer.timeScale = currentSpeed / maxMoveSpeed;
                    else mixer.timeScale = 0;
                    mixer.update(delta);
                }

                const camX = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
                const camY = camRadius * Math.cos(camPhi);
                const camZ = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
                const targetCamPos = playerContainer.position.clone().add(new THREE.Vector3(camX, camY, camZ));
                camera.position.copy(targetCamPos);
                camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);

                sunLight.target.position.set(0, 0, playerContainer.position.z);
                sunLight.target.updateMatrixWorld();
                sunLight.position.copy(sunLight.target.position).add(sunOffset);
                if (bgMesh) bgMesh.position.copy(camera.position);
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.addScaledVector(proj.userData.velocity, delta);
                proj.userData.lifeTime -= delta;
                if (proj.userData.lifeTime <= 0) { scene.remove(proj); projectiles.splice(i, 1); }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>