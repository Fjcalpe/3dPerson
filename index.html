<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - CPU Vertex Wind</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #fps-display {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.5); color: #00ff00; 
            padding: 5px 10px; border-radius: 4px;
            font-family: monospace; font-weight: bold; font-size: 14px;
            pointer-events: none; z-index: 200;
        }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="fps-display">FPS: 0</div>
    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        let blobShadow;
        const clock = new THREE.Clock();
        
        // FPS
        let lastTime = performance.now();
        let frames = 0;
        const fpsDisplay = document.getElementById('fps-display');

        const collisionMeshes = [];
        
        // --- SISTEMA DE VIENTO CPU ---
        const grassMeshes = []; // Lista de hierbas a animar
        const globalWindVector = new THREE.Vector3(1, 0, 0); // Viento hacia el ESTE (X+)

        // --- FÍSICAS ---
        const maxMoveSpeed = 11.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;

        let velocityY = 0;
        const gravity = -50.0; 
        const jumpStrength = 18.0; 
        
        let isGrounded = false;
        let landingCooldown = 0.0; 
        const LANDING_PAUSE_DURATION = 0.2; 

        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        const projectiles = [];
        const projectileSpeed = 20.0;

        let sunOffset = new THREE.Vector3(); 
        const FIXED_SETTINGS = { vert: 35, horiz: 215, intensity: 3.0, amb: 0.4, color: 0xffeeb1 };
        const keyStates = { w: false, a: false, s: false, d: false };

        const camSettings = { radius: 4.5, minRadius: 1.5, currentRadius: 4.5, theta: Math.PI, phi: 0.45 };
        const cameraRaycaster = new THREE.Raycaster();
        
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Joystick
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) {
                x = (x / distance) * maxRadius;
                y = (y / distance) * maxRadius;
            }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius;
            joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => {
            isDraggingJoystick = false;
            joystickVector = { x: 0, y: 0 };
            joystickThumb.style.transform = `translate(0px, 0px)`;
        };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        // Inputs Cámara
        document.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.ui-element')) return;
            isDraggingCamera = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointermove', (e) => {
            if (!isDraggingCamera) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            camSettings.theta -= deltaX * 0.008; 
            camSettings.phi -= deltaY * 0.008;
            camSettings.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camSettings.phi));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);

        // Teclado
        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW') keyStates.w = true;
            if(e.code==='KeyS') keyStates.s = true;
            if(e.code==='KeyA') keyStates.a = true;
            if(e.code==='KeyD') keyStates.d = true;
            if(e.code==='Space') jump();
            if(e.code==='KeyP') shoot();
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW') keyStates.w = false;
            if(e.code==='KeyS') keyStates.s = false;
            if(e.code==='KeyA') keyStates.a = false;
            if(e.code==='KeyD') keyStates.d = false;
        });

        const jumpBtn = document.getElementById('btn-jump');
        const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump));
        jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot));
        shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2)); 
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        // --- ENTORNO ---
        const textureLoader = new THREE.TextureLoader();
        const bgTexture = textureLoader.load('./bg.webp', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.environment = texture; 
            scene.environmentIntensity = 0.8; 
        });

        // Blob Shadow
        function createShadowTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0,0,0,0.6)'); gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        const shadowMat = new THREE.MeshBasicMaterial({ 
            map: createShadowTexture(), transparent: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1 
        });
        blobShadow = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), shadowMat);
        blobShadow.rotation.x = -Math.PI / 2; blobShadow.visible = false;
        scene.add(blobShadow);

        // Luz Sol
        const sunLight = new THREE.DirectionalLight(FIXED_SETTINGS.color, FIXED_SETTINGS.intensity); 
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(1024, 1024); 
        sunLight.shadow.radius = 3; 
        const d = 20; 
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        sunLight.shadow.bias = -0.001; sunLight.shadow.normalBias = 0.05; 
        scene.add(sunLight); scene.add(sunLight.target); 
        
        const hemiLight = new THREE.HemisphereLight(FIXED_SETTINGS.color, 0x000000, FIXED_SETTINGS.amb);
        scene.add(hemiLight);

        const sunDistance = 50;
        const phiSun = THREE.MathUtils.degToRad(90 - FIXED_SETTINGS.vert); 
        const thetaSun = THREE.MathUtils.degToRad(FIXED_SETTINGS.horiz);   
        sunOffset.set(sunDistance * Math.sin(phiSun) * Math.sin(thetaSun), sunDistance * Math.cos(phiSun), sunDistance * Math.sin(phiSun) * Math.cos(thetaSun));

        const gltfLoader = new GLTFLoader();
        
        // Fondo
        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); 
        sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false });
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(58);
        scene.add(bgMesh);

        const lightmapTexture = textureLoader.load('./Lightmap_Bake.webp');
        lightmapTexture.flipY = false; lightmapTexture.channel = 1; 
        
        // --- CARGA MÓDULO (PREPARACIÓN DEFORMACIÓN CPU) ---
        gltfLoader.load('./MN_SCENE_01.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const totalBox = new THREE.Box3().setFromObject(masterModule);
            const size = new THREE.Vector3();
            totalBox.getSize(size);
            
            const spacingX = size.x; 
            const spacingZ = size.z;

            // Parrilla 3x3
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    let moduleInstance = masterModule.clone(); 
                    moduleInstance.position.x = x * spacingX; 
                    moduleInstance.position.z = z * spacingZ;
                    scene.add(moduleInstance); 

                    moduleInstance.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true; 
                            child.receiveShadow = true; 
                            if (child.material) child.material.side = THREE.DoubleSide;

                            const name = child.name.toLowerCase();
                            const parentName = child.parent ? child.parent.name.toLowerCase() : "";
                            
                            const isHierba = (name.includes("hierba") || parentName.includes("hierba"));
                            const isMontes = (name.includes("montes") || parentName.includes("montes"));

                            // --- SETUP VIENTO CPU ---
                            // Si es hierba, preparamos su geometría para deformarla manualmente
                            if (isHierba && !isMontes) {
                                // 1. CLONAR GEOMETRÍA: Obligatorio para deformar cada una individualmente
                                child.geometry = child.geometry.clone();
                                
                                // 2. GUARDAR POSICIONES ORIGINALES (Base para calcular deformación)
                                const posAttribute = child.geometry.attributes.position;
                                child.userData.originalPositions = posAttribute.array.slice(); // Copia del array
                                
                                // 3. AÑADIR A LISTA DE ANIMACIÓN
                                grassMeshes.push(child);
                            }
                            
                            else if (name.includes("colision") || name.includes("collision")) {
                                child.visible = false;
                                collisionMeshes.push(child);
                            }
                            else if (name.includes("suelo")) {
                                collisionMeshes.push(child);
                            }
                        }
                    });
                }
            }
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene;
            rawCharacterMesh.scale.set(0.7, 0.7, 0.7);
            rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group();
            scene.add(playerContainer);
            playerContainer.position.set(0, 3, 0); 
            
            const box = new THREE.Box3().setFromObject(rawCharacterMesh);
            const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z);
            playerContainer.add(rawCharacterMesh);
            
            rawCharacterMesh.traverse((child) => { 
                if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; if(child.material) child.material.roughness = 0.8; }
            });
            
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(rawCharacterMesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
                mixer.timeScale = 0; 
            }
        });

        function jump() { if (isGrounded) { velocityY = jumpStrength; isGrounded = false; } }

        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
        const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        
        function shoot() {
            if (!playerContainer) return;
            const proj = new THREE.Mesh(projectileGeo, projectileMat);
            proj.position.copy(playerContainer.position);
            proj.position.y += 1.2; 
            const direction = new THREE.Vector3();
            playerContainer.getWorldDirection(direction); 
            proj.quaternion.copy(playerContainer.quaternion);
            proj.userData.velocity = direction.multiplyScalar(projectileSpeed);
            proj.userData.lifeTime = 2.0; 
            scene.add(proj);
            projectiles.push(proj);
        }

        function getEnvironmentHeight(position) {
            const origin = position.clone(); origin.y += 1.0; 
            const footRadius = 0.35; 
            const offsets = [ new THREE.Vector3(0,0,0), new THREE.Vector3(footRadius,0,0), new THREE.Vector3(-footRadius,0,0), new THREE.Vector3(0,0,footRadius), new THREE.Vector3(0,0,-footRadius) ];
            let maxHeight = -999; let hitFound = false;
            for(let i=0; i<offsets.length; i++) {
                const rayOrigin = origin.clone().add(offsets[i]);
                raycaster.set(rayOrigin, downVector); raycaster.far = 10.0; 
                const intersects = raycaster.intersectObjects(collisionMeshes, true);
                if (intersects.length > 0) {
                    const hitY = intersects[0].point.y;
                    if (hitY > maxHeight) { maxHeight = hitY; hitFound = true; }
                }
            }
            return hitFound ? maxHeight : -999;
        }

        function checkWall(position, direction) {
            const origin = position.clone(); origin.y += 0.8; 
            raycaster.set(origin, direction); raycaster.far = 0.6; 
            const intersects = raycaster.intersectObjects(collisionMeshes, true);
            return intersects.length > 0;
        }

        function updatePhysics(dt) {
            if (!playerContainer) return;
            if (landingCooldown > 0) { landingCooldown -= dt; currentSpeed = 0; }

            let inputX = joystickVector.x;
            let inputY = joystickVector.y;
            if (keyStates.w) inputY -= 1; if (keyStates.s) inputY += 1;
            if (keyStates.a) inputX -= 1; if (keyStates.d) inputX += 1;

            moveDirection.set(inputX, 0, inputY);
            const length = moveDirection.length();
            
            if (length > 0.1 && landingCooldown <= 0) { 
                isMoving = true;
                if (length > 1) { moveDirection.normalize(); currentSpeed = maxMoveSpeed; } 
                else { currentSpeed = maxMoveSpeed * length; }
            } else {
                isMoving = false;
                if (landingCooldown <= 0) currentSpeed = 0;
            }

            if (isMoving) {
                const camForward = new THREE.Vector3();
                camera.getWorldDirection(camForward); camForward.y = 0; camForward.normalize();
                const camRight = new THREE.Vector3();
                camRight.crossVectors(new THREE.Vector3(0, 1, 0), camForward).normalize();
                
                const finalMove = new THREE.Vector3();
                finalMove.addScaledVector(camForward, -moveDirection.z);
                finalMove.addScaledVector(camRight, -moveDirection.x);
                finalMove.normalize();

                if (!checkWall(playerContainer.position, finalMove)) {
                    playerContainer.position.addScaledVector(finalMove, currentSpeed * dt);
                }
                const targetAngle = Math.atan2(finalMove.x, finalMove.z);
                const targetQuaternion = new THREE.Quaternion();
                targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                playerContainer.quaternion.slerp(targetQuaternion, 10 * dt);
            }

            velocityY += gravity * dt;
            let proposedY = playerContainer.position.y + velocityY * dt;
            const floorY = getEnvironmentHeight(playerContainer.position);
            
            if (blobShadow) {
                if (floorY > -500) { blobShadow.visible = true; blobShadow.position.set(playerContainer.position.x, floorY + 0.05, playerContainer.position.z); } 
                else { blobShadow.visible = false; }
            }

            if (proposedY <= floorY && velocityY <= 0) {
                if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; 
                playerContainer.position.y = floorY;
                velocityY = 0;
                isGrounded = true;
            } else if (proposedY <= 0) {
                if (!isGrounded) landingCooldown = LANDING_PAUSE_DURATION; 
                playerContainer.position.y = 0;
                velocityY = 0;
                isGrounded = true;
            } else {
                playerContainer.position.y = proposedY;
                isGrounded = false;
            }
        }

        function updateSmartCamera() {
            if (!playerContainer) return;

            const targetCamX = camSettings.radius * Math.sin(camSettings.phi) * Math.sin(camSettings.theta);
            const targetCamY = camSettings.radius * Math.cos(camSettings.phi);
            const targetCamZ = camSettings.radius * Math.sin(camSettings.phi) * Math.cos(camSettings.theta);
            
            const idealPos = playerContainer.position.clone().add(new THREE.Vector3(targetCamX, targetCamY, targetCamZ));
            const playerHead = playerContainer.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const direction = new THREE.Vector3().subVectors(idealPos, playerHead).normalize();
            
            cameraRaycaster.set(playerHead, direction);
            cameraRaycaster.far = camSettings.radius;

            const hits = cameraRaycaster.intersectObjects(collisionMeshes, true);
            
            let finalDistance = camSettings.radius;
            if (hits.length > 0) {
                finalDistance = Math.max(camSettings.minRadius, hits[0].distance - 0.2);
            }

            const correctedPos = playerHead.clone().add(direction.multiplyScalar(finalDistance));
            camera.position.lerp(correctedPos, 0.2); 
            camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            frames++;
            if (time >= lastTime + 1000) { fpsDisplay.innerText = "FPS: " + frames; frames = 0; lastTime = time; }

            let delta = Math.min(clock.getDelta(), 0.1); 
            const elapsed = clock.getElapsedTime();

            // --- ANIMACIÓN VIENTO (DEFORMACIÓN VÉRTICES CPU) ---
            // Esta técnica es pesada pero 100% segura visualmente
            
            // 1. Calcular Viento Global (Dirección X+)
            const windSpeed = 3.0;
            // Usamos (sin + 1) / 2 para empuje positivo (0 a 1)
            const windPulse = (Math.sin(elapsed * windSpeed) + 1.0) * 0.5;
            const windStrength = windPulse * 0.5 + 0.1; // Intensidad base
            
            // Vector de viento global
            globalWindVector.set(1, 0, 0).multiplyScalar(windStrength);

            // 2. Iterar sobre cada objeto de hierba
            for (let i = 0; i < grassMeshes.length; i++) {
                const mesh = grassMeshes[i];
                const originalPos = mesh.userData.originalPositions;
                const currentPos = mesh.geometry.attributes.position.array;
                
                // 3. Convertir Viento Global a Local
                // Usamos la inversa de la rotación del objeto
                const inverseRot = mesh.quaternion.clone().invert();
                const localWind = globalWindVector.clone().applyQuaternion(inverseRot);
                
                // 4. Deformar Vértices
                for (let j = 0; j < originalPos.length; j += 3) {
                    const ox = originalPos[j];
                    const oy = originalPos[j+1];
                    const oz = originalPos[j+2];
                    
                    if (oy <= 0.1) continue; // Base quieta
                    
                    // Curvatura Cuadrática
                    const bend = oy * oy * 0.5;
                    
                    // Aplicar desplazamiento
                    currentPos[j]   = ox + localWind.x * bend;
                    currentPos[j+1] = oy - bend * 0.2; // Acortar
                    currentPos[j+2] = oz + localWind.z * bend;
                }
                mesh.geometry.attributes.position.needsUpdate = true;
            }

            const timeStep = 1/60; let steps = Math.ceil(delta / timeStep); if(steps > 4) steps = 4; 
            for(let i=0; i<steps; i++) updatePhysics(delta / steps);

            if (playerContainer) {
                if (mixer) {
                    if (isGrounded && isMoving) mixer.timeScale = currentSpeed / maxMoveSpeed;
                    else mixer.timeScale = 0;
                    mixer.update(delta);
                }
                updateSmartCamera();
                sunLight.target.position.set(0, 0, playerContainer.position.z);
                sunLight.target.updateMatrixWorld();
                sunLight.position.copy(sunLight.target.position).add(sunOffset);
                if (bgMesh) bgMesh.position.copy(camera.position);
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.addScaledVector(proj.userData.velocity, delta);
                proj.userData.lifeTime -= delta;
                if (proj.userData.lifeTime <= 0) { scene.remove(proj); projectiles.splice(i, 1); }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>