<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - Raycast Physics Stable</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #settings-ui {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.8); color: #00ff00; 
            padding: 10px; border-radius: 4px;
            text-align: right; z-index: 200; font-family: monospace;
            border: 1px solid #00ff00;
        }
        #settings-ui label { font-size: 11px; display: block; margin-bottom: 5px; color: white; cursor: pointer; }
        .divider { border: 0; border-top: 1px solid #555; margin: 8px 0; }

        #info {
            position: absolute; top: 10px; left: 10px;
            color: rgba(255, 255, 255, 0.8); pointer-events: none; z-index: 10;
            text-align: left;
        }
        .ui-element { pointer-events: auto; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Físicas: RAYCAST (Estable)<br>Flecha Verde = Suelo | Roja = Pared</div>
    
    <div id="settings-ui" class="ui-element">
        <div id="debug-stats">Grounded: false</div>
        <hr class="divider">
        <label>
            <input type="checkbox" id="wireframe-toggle"> Ver Malla Visual
        </label>
        <label>
            <input type="checkbox" id="collider-debug" checked> Ver Rayos Debug
        </label>
    </div>

    <div id="pc-instructions">WASD: Mover | ESPACIO: Saltar</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        const clock = new THREE.Clock();
        
        // --- FÍSICAS ---
        const maxMoveSpeed = 8.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;

        let velocityY = 0;
        const gravity = -40.0; // Gravedad fuerte para sensación arcade
        const jumpStrength = 14.0; 
        let isGrounded = false;

        // SISTEMA DE COLISIONES (RAYCAST)
        const collisionMeshes = []; // Lista de mallas contra las que chocamos
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        
        // Helpers visuales para depurar
        let groundArrow, wallArrow;

        const projectiles = [];
        const projectileSpeed = 20.0;

        let sunOffset = new THREE.Vector3(); 
        const FIXED_SETTINGS = { vert: 35, horiz: 215, intensity: 3.0, amb: 0.4, color: 0xffeeb1 };
        const keyStates = { w: false, a: false, s: false, d: false };

        // CÁMARA
        const defaultCamData = { radius: 3.2, theta: 0.00, phi: 0.60 };
        let camRadius = defaultCamData.radius;
        let camTheta = defaultCamData.theta;
        let camPhi = defaultCamData.phi;
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };

        // UI
        const wireframeToggle = document.getElementById('wireframe-toggle');
        const colliderDebugToggle = document.getElementById('collider-debug');
        const debugStats = document.getElementById('debug-stats');
        
        wireframeToggle.addEventListener('change', (e) => {
            const isWireframe = e.target.checked;
            scene.traverse((child) => {
                if (child.isMesh && child.material && !child.userData.isCollider && child !== bgMesh) {
                    child.material.wireframe = isWireframe;
                }
            });
        });

        colliderDebugToggle.addEventListener('change', (e) => {
            const show = e.target.checked;
            if(groundArrow) groundArrow.visible = show;
            if(wallArrow) wallArrow.visible = show;
            // Mostrar/Ocultar mallas de colisión invisibles
            collisionMeshes.forEach(mesh => {
                if(mesh.userData.isCollider) {
                    mesh.material.visible = show; // Solo visible en modo debug
                    mesh.material.wireframe = true;
                }
            });
        });

        document.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.ui-element')) return;
            isDraggingCamera = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointermove', (e) => {
            if (!isDraggingCamera) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            camTheta -= deltaX * 0.005; 
            camPhi -= deltaY * 0.005;
            camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPhi));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);

        // Joystick
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) {
                x = (x / distance) * maxRadius;
                y = (y / distance) * maxRadius;
            }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius;
            joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => {
            isDraggingJoystick = false;
            joystickVector = { x: 0, y: 0 };
            joystickThumb.style.transform = `translate(0px, 0px)`;
        };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        // Inputs
        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW') keyStates.w = true;
            if(e.code==='KeyS') keyStates.s = true;
            if(e.code==='KeyA') keyStates.a = true;
            if(e.code==='KeyD') keyStates.d = true;
            if(e.code==='Space') jump();
            if(e.code==='KeyP') shoot();
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW') keyStates.w = false;
            if(e.code==='KeyS') keyStates.s = false;
            if(e.code==='KeyA') keyStates.a = false;
            if(e.code==='KeyD') keyStates.d = false;
        });

        const jumpBtn = document.getElementById('btn-jump');
        const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump));
        jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot));
        shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envTexture = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.environment = envTexture;
        scene.environmentIntensity = 0.5; 

        // Debug Arrows
        groundArrow = new THREE.ArrowHelper(downVector, new THREE.Vector3(), 1, 0x00ff00);
        wallArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 1, 0xff0000);
        scene.add(groundArrow);
        scene.add(wallArrow);

        // LUZ SOL
        const sunLight = new THREE.DirectionalLight(FIXED_SETTINGS.color, FIXED_SETTINGS.intensity); 
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(1024, 1024); 
        sunLight.shadow.radius = 3; 
        const d = 20; 
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        sunLight.shadow.bias = -0.001;  
        sunLight.shadow.normalBias = 0.05; 
        scene.add(sunLight); scene.add(sunLight.target); 
        
        const hemiLight = new THREE.HemisphereLight(FIXED_SETTINGS.color, 0x000000, FIXED_SETTINGS.amb);
        scene.add(hemiLight);

        const sunDistance = 50;
        const phiSun = THREE.MathUtils.degToRad(90 - FIXED_SETTINGS.vert); 
        const thetaSun = THREE.MathUtils.degToRad(FIXED_SETTINGS.horiz);   
        sunOffset.set(sunDistance * Math.sin(phiSun) * Math.sin(thetaSun), sunDistance * Math.cos(phiSun), sunDistance * Math.sin(phiSun) * Math.cos(thetaSun));

        const gltfLoader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();
        
        // FONDO
        const bgTexture = textureLoader.load('./bg.webp');
        bgTexture.colorSpace = THREE.SRGBColorSpace; 
        const sphereGeo = new THREE.SphereGeometry(500, 32, 16); 
        sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ 
            map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false 
        });
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        bgMesh.rotation.y = THREE.MathUtils.degToRad(58);
        scene.add(bgMesh);

        // --- PLATAFORMAS FLOTANTES ---
        function addPlatform(x, y, z) {
            const geo = new THREE.BoxGeometry(2.5, 0.2, 2.5); 
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.frustumCulled = false; // Fix parpadeo
            scene.add(mesh);

            // Añadir a colisionadores
            collisionMeshes.push(mesh);
        }

        addPlatform(0, 2.0, -15);
        addPlatform(-2, 3.5, -22);
        addPlatform(2, 5.0, -30);


        const lightmapTexture = textureLoader.load('./Lightmap_Bake.webp');
        lightmapTexture.flipY = false; lightmapTexture.channel = 1; 
        
        // --- CARGAR MÓDULO + COLISIÓN EMBEBIDA ---
        gltfLoader.load('./modulo_1.gltf', function (gltf) {
            const masterModule = gltf.scene;
            const totalBox = new THREE.Box3().setFromObject(masterModule);
            const size = new THREE.Vector3();
            totalBox.getSize(size);

            for (let i = 0; i < 6; i++) { 
                let moduleInstance = masterModule.clone(); 
                let zPos = - (i * size.z);
                moduleInstance.position.z = zPos;
                scene.add(moduleInstance); 

                // --- PROCESAR INSTANCIA ---
                moduleInstance.traverse((child) => {
                    const nameLower = child.name.toLowerCase();

                    // 1. ¿ES MALLA DE COLISIÓN?
                    if (nameLower.includes("colision") || nameLower.includes("collision")) {
                        child.material = new THREE.MeshBasicMaterial({ 
                            color: 0xff0000, 
                            wireframe: true,
                            transparent: true,
                            opacity: 0.0, // Invisible por defecto
                            side: THREE.DoubleSide // Asegurar que el rayo choque por ambos lados
                        });
                        child.userData.isCollider = true;
                        child.visible = true; // Tiene que ser 'visible' para que el raycaster lo detecte, aunque el material sea transparente
                        
                        collisionMeshes.push(child);
                    
                    // 2. PARTE VISUAL
                    } else if (child.isMesh) {
                        child.material.lightMap = lightmapTexture; 
                        child.material.lightMapIntensity = 1.0; 
                        child.material.aoMap = lightmapTexture; 
                        child.material.aoMapIntensity = 1.0; 
                        child.material.envMapIntensity = 0.1; 
                        child.material.side = THREE.DoubleSide; 
                        child.castShadow = true; 
                        child.receiveShadow = true; 
                    }
                });
            }
            addDecoLights(masterModule, size.z);
        });

        gltfLoader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene;
            rawCharacterMesh.scale.set(0.7, 0.7, 0.7);
            rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group();
            scene.add(playerContainer);
            // Iniciamos un poco elevados para no caer al vacío si la carga tarda
            playerContainer.position.set(0, 5, 0); 
            
            const box = new THREE.Box3().setFromObject(rawCharacterMesh);
            const center = box.getCenter(new THREE.Vector3());
            // Ajuste visual del modelo dentro del contenedor
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z);
            playerContainer.add(rawCharacterMesh);
            
            rawCharacterMesh.traverse((child) => { 
                if (child.isMesh) { 
                    child.castShadow = true; 
                    child.receiveShadow = true; 
                    if(child.material) child.material.roughness = 0.8; 
                }
            });
            
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(rawCharacterMesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
                mixer.timeScale = 0; 
            }
        });

        function addDecoLights(module, lengthZ) { const positions = [ { x: -3.8, z: -lengthZ * 0.20 }, { x:  3.8, z: -lengthZ * 0.20 }, { x: -3.8, z: -lengthZ * 0.80 }, { x:  3.8, z: -lengthZ * 0.80 } ]; const bulbMat = new THREE.MeshBasicMaterial({ color: 0xccffff }); const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8); positions.forEach(pos => { const bulb = new THREE.Mesh(bulbGeo, bulbMat); bulb.position.set(pos.x, 2.9, pos.z); module.add(bulb); }); }

        function jump() {
            if (isGrounded) { 
                velocityY = jumpStrength; 
                isGrounded = false; 
            }
        }

        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
        const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        
        function shoot() {
            if (!playerContainer) return;
            const proj = new THREE.Mesh(projectileGeo, projectileMat);
            proj.position.copy(playerContainer.position);
            proj.position.y += 1.2; 
            const direction = new THREE.Vector3();
            playerContainer.getWorldDirection(direction); 
            proj.quaternion.copy(playerContainer.quaternion);
            proj.userData.velocity = direction.multiplyScalar(projectileSpeed);
            proj.userData.lifeTime = 2.0; 
            scene.add(proj);
            projectiles.push(proj);
        }

        // --- SISTEMA FÍSICO RAYCAST ---
        function getEnvironmentHeight(position) {
            // Origen: Un poco arriba del jugador
            const origin = position.clone();
            origin.y += 1.0; 
            
            raycaster.set(origin, downVector);
            raycaster.far = 10.0; // No buscar suelo infinito

            // Debug visual
            if (groundArrow) {
                groundArrow.position.copy(origin);
                groundArrow.setDirection(downVector);
            }

            const intersects = raycaster.intersectObjects(collisionMeshes, true);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            return -999; // Vacío
        }

        function checkWall(position, direction) {
            // Rayo desde el pecho hacia adelante
            const origin = position.clone();
            origin.y += 0.8; 
            
            // Debug
            if (wallArrow) {
                wallArrow.position.copy(origin);
                wallArrow.setDirection(direction);
            }

            raycaster.set(origin, direction);
            raycaster.far = 0.6; // Distancia de choque (radio jugador)
            
            const intersects = raycaster.intersectObjects(collisionMeshes, true);
            return intersects.length > 0;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1); 
            
            if (bgMesh) bgMesh.position.copy(camera.position);

            if (playerContainer) {
                // 1. INPUT
                let inputX = joystickVector.x;
                let inputY = joystickVector.y;
                if (keyStates.w) inputY -= 1;
                if (keyStates.s) inputY += 1;
                if (keyStates.a) inputX -= 1;
                if (keyStates.d) inputX += 1;

                moveDirection.set(inputX, 0, inputY);
                const length = moveDirection.length();
                
                if (length > 0.1) { 
                    isMoving = true;
                    if (length > 1) { moveDirection.normalize(); currentSpeed = maxMoveSpeed; } 
                    else { currentSpeed = maxMoveSpeed * length; }
                } else {
                    isMoving = false;
                    currentSpeed = 0;
                }

                // 2. MOVIMIENTO HORIZONTAL
                if (isMoving) {
                    const worldDirection = moveDirection.clone();
                    
                    // Si NO hay pared enfrente, movemos
                    if (!checkWall(playerContainer.position, worldDirection)) {
                        playerContainer.position.addScaledVector(moveDirection, currentSpeed * delta);
                    }

                    const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                    const targetQuaternion = new THREE.Quaternion();
                    targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    playerContainer.quaternion.slerp(targetQuaternion, 10 * delta);

                    if (mixer && isGrounded) mixer.timeScale = currentSpeed / maxMoveSpeed;
                    
                    let diffTheta = defaultCamData.theta - camTheta;
                    while (diffTheta > Math.PI) diffTheta -= Math.PI * 2;
                    while (diffTheta < -Math.PI) diffTheta += Math.PI * 2;
                    camTheta += diffTheta * 3.0 * delta;
                    camPhi += (defaultCamData.phi - camPhi) * 3.0 * delta;

                } else {
                    if (mixer) mixer.timeScale = 0;
                }

                // 3. FÍSICAS VERTICALES (Estilo Arcade)
                velocityY += gravity * delta;
                
                // Calculamos nueva Y propuesta por gravedad
                let proposedY = playerContainer.position.y + velocityY * delta;
                
                // ¿Dónde está el suelo realmente?
                const floorY = getEnvironmentHeight(playerContainer.position);
                
                // Lógica de Aterrizaje
                // Si vamos a atravesar el suelo (proposedY < floorY) Y estamos cayendo
                if (proposedY <= floorY && velocityY <= 0) {
                    // Aterrizamos suavemente
                    playerContainer.position.y = floorY;
                    velocityY = 0;
                    isGrounded = true;
                } else if (proposedY <= 0) {
                    // Suelo base de seguridad (nivel 0)
                    playerContainer.position.y = 0;
                    velocityY = 0;
                    isGrounded = true;
                } else {
                    // En el aire
                    playerContainer.position.y = proposedY;
                    isGrounded = false;
                    if(mixer) mixer.timeScale = 0;
                }
                
                // Debug Info
                debugStats.innerText = `Grounded: ${isGrounded} | Y: ${playerContainer.position.y.toFixed(2)}`;

                // CÁMARA
                const camX = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
                const camY = camRadius * Math.cos(camPhi);
                const camZ = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
                const targetCamPos = playerContainer.position.clone().add(new THREE.Vector3(camX, camY, camZ));
                camera.position.copy(targetCamPos);
                camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);

                sunLight.target.position.set(0, 0, playerContainer.position.z);
                sunLight.target.updateMatrixWorld();
                sunLight.position.copy(sunLight.target.position).add(sunOffset);
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.addScaledVector(proj.userData.velocity, delta);
                proj.userData.lifeTime -= delta;
                if (proj.userData.lifeTime <= 0) { scene.remove(proj); projectiles.splice(i, 1); }
            }

            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>