<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Juego 3D - Final 58 deg</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none;
        }
        
        #settings-ui {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.6); color: white;
            padding: 10px; border-radius: 8px;
            text-align: right; z-index: 200;
        }
        #settings-ui label { font-size: 12px; display: block; margin-bottom: 5px; }
        #settings-ui input { width: 150px; }

        #info {
            position: absolute; top: 10px; left: 10px;
            color: rgba(255, 255, 255, 0.5); pointer-events: none; z-index: 10;
            text-align: left;
        }
        .ui-element { pointer-events: auto; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; touch-action: none; cursor: pointer;
        }
        #joystick-thumb {
            width: 50px; height: 50px;
            background: rgba(255, 238, 177, 0.8);
            border-radius: 50%;
            position: absolute; transform: translate(0px, 0px); 
            pointer-events: none; 
        }

        #actions-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 15px; z-index: 100;
        }
        .action-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold;
            cursor: pointer; backdrop-filter: blur(4px); touch-action: none;
        }
        .action-btn:active { background: rgba(255, 238, 177, 0.5); transform: scale(0.95); }
        #btn-shoot { background: rgba(255, 50, 50, 0.3); } 

        @media (max-width: 800px) { #pc-instructions { display: none; } }
        #pc-instructions {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.3); font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">BG: 58° | Fix Acné++</div>
    
    <div id="settings-ui" class="ui-element">
        <label>Rotación Fondo: <span id="bg-rot-val">58°</span></label>
        <input type="range" id="bg-rot-slider" min="0" max="360" value="58">
    </div>

    <div id="pc-instructions">WASD: Mover | Arrastrar: Cámara Libre</div>

    <div id="joystick-container" class="ui-element"><div id="joystick-thumb"></div></div>

    <div id="actions-container" class="ui-element">
        <div class="action-btn" id="btn-jump">SALTAR</div>
        <div class="action-btn" id="btn-shoot">DISPARAR</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        let mixer, playerContainer, rawCharacterMesh, bgMesh; 
        const clock = new THREE.Clock();
        
        const maxMoveSpeed = 8.0; 
        let currentSpeed = 0;
        let moveDirection = new THREE.Vector3();
        let isMoving = false;

        let velocityY = 0;
        const gravity = -25.0;
        const jumpStrength = 10.0;
        let isGrounded = true;

        const projectiles = [];
        const projectileSpeed = 20.0;

        let sunOffset = new THREE.Vector3(); 
        const FIXED_SETTINGS = { vert: 35, horiz: 215, intensity: 3.0, amb: 0.4, color: 0xffeeb1 };
        const keyStates = { w: false, a: false, s: false, d: false };

        // CÁMARA
        const defaultCamData = { radius: 3.2, theta: 0.00, phi: 0.60 };
        let camRadius = defaultCamData.radius;
        let camTheta = defaultCamData.theta;
        let camPhi = defaultCamData.phi;
        let isDraggingCamera = false;
        let previousMousePosition = { x: 0, y: 0 };

        const bgSlider = document.getElementById('bg-rot-slider');
        const bgVal = document.getElementById('bg-rot-val');
        
        bgSlider.addEventListener('input', (e) => {
            if (bgMesh) {
                const degrees = e.target.value;
                bgVal.innerText = degrees + '°';
                const radians = THREE.MathUtils.degToRad(degrees);
                bgMesh.rotation.y = radians;
            }
        });

        document.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.ui-element')) return;
            isDraggingCamera = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointermove', (e) => {
            if (!isDraggingCamera) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            camTheta -= deltaX * 0.005; 
            camPhi -= deltaY * 0.005;
            camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPhi));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('pointerup', () => isDraggingCamera = false);
        document.addEventListener('pointercancel', () => isDraggingCamera = false);

        // Joystick
        let joystickVector = { x: 0, y: 0 }; 
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const maxRadius = joystickContainer.clientWidth / 2;
        let isDraggingJoystick = false;

        const handleJoystick = (e) => {
            if(e.type.startsWith('touch')) e.preventDefault();
            if (!isDraggingJoystick) return;
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            let clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            let x = clientX - centerX;
            let y = clientY - centerY;
            let distance = Math.sqrt(x*x + y*y);
            if (distance > maxRadius) {
                x = (x / distance) * maxRadius;
                y = (y / distance) * maxRadius;
            }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickVector.x = x / maxRadius;
            joystickVector.y = y / maxRadius; 
        };
        const resetJoystick = () => {
            isDraggingJoystick = false;
            joystickVector = { x: 0, y: 0 };
            joystickThumb.style.transform = `translate(0px, 0px)`;
        };
        joystickContainer.addEventListener('mousedown', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        window.addEventListener('mousemove', (e) => { if(isDraggingJoystick) handleJoystick(e); });
        window.addEventListener('mouseup', resetJoystick);
        joystickContainer.addEventListener('touchstart', (e) => { isDraggingJoystick = true; handleJoystick(e); });
        joystickContainer.addEventListener('touchmove', handleJoystick);
        joystickContainer.addEventListener('touchend', resetJoystick);

        // Inputs
        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW') keyStates.w = true;
            if(e.code==='KeyS') keyStates.s = true;
            if(e.code==='KeyA') keyStates.a = true;
            if(e.code==='KeyD') keyStates.d = true;
            if(e.code==='Space') jump();
            if(e.code==='KeyP') shoot();
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW') keyStates.w = false;
            if(e.code==='KeyS') keyStates.s = false;
            if(e.code==='KeyA') keyStates.a = false;
            if(e.code==='KeyD') keyStates.d = false;
        });

        const jumpBtn = document.getElementById('btn-jump');
        const shootBtn = document.getElementById('btn-shoot');
        const triggerAction = (action) => (e) => { e.preventDefault(); action(); };
        jumpBtn.addEventListener('touchstart', triggerAction(jump));
        jumpBtn.addEventListener('mousedown', triggerAction(jump));
        shootBtn.addEventListener('touchstart', triggerAction(shoot));
        shootBtn.addEventListener('mousedown', triggerAction(shoot));

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0)); 
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envTexture = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.environment = envTexture;
        scene.environmentIntensity = 0.5; 

        // LUZ SOL
        const sunLight = new THREE.DirectionalLight(FIXED_SETTINGS.color, FIXED_SETTINGS.intensity); 
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048); 
        const d = 50; 
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d; sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 150; 
        
        // --- FIX ACNÉ AGRESIVO ---
        sunLight.shadow.bias = -0.001;  // Más negativo
        sunLight.shadow.normalBias = 0.1; // Bastante alto para alejar el self-shadowing
        scene.add(sunLight); scene.add(sunLight.target); 
        
        const hemiLight = new THREE.HemisphereLight(FIXED_SETTINGS.color, 0x000000, FIXED_SETTINGS.amb);
        scene.add(hemiLight);

        const sunDistance = 50;
        const phiSun = THREE.MathUtils.degToRad(90 - FIXED_SETTINGS.vert); 
        const thetaSun = THREE.MathUtils.degToRad(FIXED_SETTINGS.horiz);   
        sunOffset.set(sunDistance * Math.sin(phiSun) * Math.sin(thetaSun), sunDistance * Math.cos(phiSun), sunDistance * Math.sin(phiSun) * Math.cos(thetaSun));

        const loader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();
        
        // FONDO (58 grados default)
        const bgTexture = textureLoader.load('./bg.webp');
        bgTexture.colorSpace = THREE.SRGBColorSpace; 
        const sphereGeo = new THREE.SphereGeometry(500, 60, 40); 
        sphereGeo.scale(-1, 1, 1); 
        const sphereMat = new THREE.MeshBasicMaterial({ 
            map: bgTexture, side: THREE.DoubleSide, fog: false, depthWrite: false, toneMapped: false 
        });
        bgMesh = new THREE.Mesh(sphereGeo, sphereMat);
        
        // ROTACIÓN INICIAL 58 GRADOS
        bgMesh.rotation.y = THREE.MathUtils.degToRad(58);
        scene.add(bgMesh);

        const lightmapTexture = textureLoader.load('./Lightmap_Bake.webp');
        lightmapTexture.flipY = false; lightmapTexture.channel = 1; 
        loader.load('./modulo_1.gltf', function (gltf) {
            const originalModule = gltf.scene;
            const size = new THREE.Vector3();
            new THREE.Box3().setFromObject(originalModule).getSize(size);
            originalModule.traverse((child) => { if (child.isMesh) { child.material.lightMap = lightmapTexture; child.material.lightMapIntensity = 1.0; child.material.aoMap = lightmapTexture; child.material.aoMapIntensity = 1.0; child.material.envMapIntensity = 0.1; child.material.side = THREE.DoubleSide; child.castShadow = true; child.receiveShadow = true; } });
            
            for (let i = 0; i < 6; i++) { 
                let moduleInstance = (i === 0) ? originalModule : originalModule.clone(); 
                moduleInstance.position.z = - (i * size.z); 
                scene.add(moduleInstance); 
            }
            addDecoLights(originalModule, size.z);
        });

        loader.load('./GIRLrun.gltf', function (gltf) {
            rawCharacterMesh = gltf.scene;
            rawCharacterMesh.scale.set(0.7, 0.7, 0.7);
            rawCharacterMesh.updateMatrixWorld(true); 
            playerContainer = new THREE.Group();
            scene.add(playerContainer);
            const box = new THREE.Box3().setFromObject(rawCharacterMesh);
            const center = box.getCenter(new THREE.Vector3());
            rawCharacterMesh.position.set(-center.x, -box.min.y, -center.z);
            playerContainer.add(rawCharacterMesh);
            
            rawCharacterMesh.traverse((child) => { 
                if (child.isMesh) { 
                    child.castShadow = true; 
                    child.receiveShadow = true; 
                    if(child.material) {
                         child.material.roughness = 0.8; 
                    }
                }
            });
            
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(rawCharacterMesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
                mixer.timeScale = 0; 
            }
        });

        function addDecoLights(module, lengthZ) { const positions = [ { x: -3.8, z: -lengthZ * 0.20 }, { x:  3.8, z: -lengthZ * 0.20 }, { x: -3.8, z: -lengthZ * 0.80 }, { x:  3.8, z: -lengthZ * 0.80 } ]; const bulbMat = new THREE.MeshBasicMaterial({ color: 0xccffff }); const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8); positions.forEach(pos => { const bulb = new THREE.Mesh(bulbGeo, bulbMat); bulb.position.set(pos.x, 2.9, pos.z); module.add(bulb); }); }

        function jump() {
            if (isGrounded) { velocityY = jumpStrength; isGrounded = false; }
        }

        const projectileGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
        const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        
        function shoot() {
            if (!playerContainer) return;
            const proj = new THREE.Mesh(projectileGeo, projectileMat);
            proj.position.copy(playerContainer.position);
            proj.position.y += 1.2; 
            const direction = new THREE.Vector3();
            playerContainer.getWorldDirection(direction); 
            proj.quaternion.copy(playerContainer.quaternion);
            proj.userData.velocity = direction.multiplyScalar(projectileSpeed);
            proj.userData.lifeTime = 2.0; 
            scene.add(proj);
            projectiles.push(proj);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1); 
            
            if (bgMesh) {
                bgMesh.position.copy(camera.position);
            }

            if (playerContainer) {
                let inputX = joystickVector.x;
                let inputY = joystickVector.y;
                if (keyStates.w) inputY -= 1;
                if (keyStates.s) inputY += 1;
                if (keyStates.a) inputX -= 1;
                if (keyStates.d) inputX += 1;

                moveDirection.set(inputX, 0, inputY);
                const length = moveDirection.length();
                
                if (length > 0.1) { 
                    isMoving = true;
                    if (length > 1) { moveDirection.normalize(); currentSpeed = maxMoveSpeed; } 
                    else { currentSpeed = maxMoveSpeed * length; }
                } else {
                    isMoving = false;
                    currentSpeed = 0;
                }

                if (isMoving) {
                    playerContainer.position.addScaledVector(moveDirection.normalize(), currentSpeed * delta);

                    const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                    const targetQuaternion = new THREE.Quaternion();
                    targetQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    playerContainer.quaternion.slerp(targetQuaternion, 10 * delta);

                    if (mixer && isGrounded) mixer.timeScale = currentSpeed / maxMoveSpeed;
                    
                    let diffTheta = defaultCamData.theta - camTheta;
                    while (diffTheta > Math.PI) diffTheta -= Math.PI * 2;
                    while (diffTheta < -Math.PI) diffTheta += Math.PI * 2;
                    camTheta += diffTheta * 3.0 * delta;
                    camPhi += (defaultCamData.phi - camPhi) * 3.0 * delta;

                } else {
                    if (mixer) mixer.timeScale = 0;
                }

                velocityY += gravity * delta;
                playerContainer.position.y += velocityY * delta;
                if (playerContainer.position.y <= 0) {
                    playerContainer.position.y = 0; velocityY = 0; isGrounded = true;
                } else { isGrounded = false; if(mixer) mixer.timeScale = 0; }

                const camX = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
                const camY = camRadius * Math.cos(camPhi);
                const camZ = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
                const targetCamPos = playerContainer.position.clone().add(new THREE.Vector3(camX, camY, camZ));
                camera.position.copy(targetCamPos);
                camera.lookAt(playerContainer.position.x, playerContainer.position.y + 1.5, playerContainer.position.z);

                sunLight.target.position.set(0, 0, playerContainer.position.z);
                sunLight.target.updateMatrixWorld();
                sunLight.position.copy(sunLight.target.position).add(sunOffset);
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.addScaledVector(proj.userData.velocity, delta);
                proj.userData.lifeTime -= delta;
                if (proj.userData.lifeTime <= 0) { scene.remove(proj); projectiles.splice(i, 1); }
            }

            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        document.addEventListener('gesturestart', (e) => e.preventDefault());

        animate();
    </script>
</body>
</html>